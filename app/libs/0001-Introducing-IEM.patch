From c3b71cfcc0a66c9bc821a207fdb1a1f16c53c03d Mon Sep 17 00:00:00 2001
From: mikalackis <mikalackis@gmail.com>
Date: Mon, 18 Jul 2016 09:29:10 +0200
Subject: [PATCH] Introducing IEM

---
 core/java/android/content/Intent.java              |   14 +
 core/java/android/provider/ArielSettings.java      | 1652 -----------------
 packages/ArielSettingsProvider/Android.mk          |   18 -
 packages/ArielSettingsProvider/AndroidManifest.xml |   20 -
 .../ArielSettingsProvider/MODULE_LICENSE_APACHE2   |    0
 packages/ArielSettingsProvider/NOTICE              |  190 --
 .../res/mipmap-hdpi/ic_launcher_settings.png       |  Bin 8822 -> 0 bytes
 .../res/mipmap-mdpi/ic_launcher_settings.png       |  Bin 5362 -> 0 bytes
 .../res/mipmap-xhdpi/ic_launcher_settings.png      |  Bin 12096 -> 0 bytes
 .../res/mipmap-xxhdpi/ic_launcher_settings.png     |  Bin 20300 -> 0 bytes
 .../res/mipmap-xxxhdpi/ic_launcher_settings.png    |  Bin 27997 -> 0 bytes
 .../ArielSettingsProvider/res/values/defaults.xml  |   21 -
 .../ArielSettingsProvider/res/values/strings.xml   |   22 -
 .../ArielSettingsProvider/res/xml/bookmarks.xml    |   59 -
 .../arielsettings/ArielSettingsHelper.java         |  177 --
 .../arielsettings/ArielSettingsProvider.java       | 1861 --------------------
 .../arielsettings/ArielSettingsState.java          |  658 -------
 .../providers/arielsettings/DatabaseHelper.java    |  521 ------
 .../providers/arielsettings/EventLogTags.logtags   |    5 -
 packages/ArielSettingsProvider/test/Android.mk     |   16 -
 .../ArielSettingsProvider/test/AndroidManifest.xml |   35 -
 services/core/Android.mk                           |    3 +-
 .../java/com/android/server/am/ActiveServices.java |   31 +-
 .../android/server/am/ActivityManagerService.java  |   76 +-
 .../android/server/firewall/IntentFirewall.java    |  861 ++++++++-
 .../android/server/policy/PhoneWindowManager.java  |    2 +-
 26 files changed, 966 insertions(+), 5276 deletions(-)
 delete mode 100644 core/java/android/provider/ArielSettings.java
 delete mode 100644 packages/ArielSettingsProvider/Android.mk
 delete mode 100644 packages/ArielSettingsProvider/AndroidManifest.xml
 delete mode 100644 packages/ArielSettingsProvider/MODULE_LICENSE_APACHE2
 delete mode 100644 packages/ArielSettingsProvider/NOTICE
 delete mode 100644 packages/ArielSettingsProvider/res/mipmap-hdpi/ic_launcher_settings.png
 delete mode 100644 packages/ArielSettingsProvider/res/mipmap-mdpi/ic_launcher_settings.png
 delete mode 100644 packages/ArielSettingsProvider/res/mipmap-xhdpi/ic_launcher_settings.png
 delete mode 100644 packages/ArielSettingsProvider/res/mipmap-xxhdpi/ic_launcher_settings.png
 delete mode 100644 packages/ArielSettingsProvider/res/mipmap-xxxhdpi/ic_launcher_settings.png
 delete mode 100644 packages/ArielSettingsProvider/res/values/defaults.xml
 delete mode 100644 packages/ArielSettingsProvider/res/values/strings.xml
 delete mode 100644 packages/ArielSettingsProvider/res/xml/bookmarks.xml
 delete mode 100644 packages/ArielSettingsProvider/src/com/android/providers/arielsettings/ArielSettingsHelper.java
 delete mode 100644 packages/ArielSettingsProvider/src/com/android/providers/arielsettings/ArielSettingsProvider.java
 delete mode 100644 packages/ArielSettingsProvider/src/com/android/providers/arielsettings/ArielSettingsState.java
 delete mode 100644 packages/ArielSettingsProvider/src/com/android/providers/arielsettings/DatabaseHelper.java
 delete mode 100644 packages/ArielSettingsProvider/src/com/android/providers/arielsettings/EventLogTags.logtags
 delete mode 100644 packages/ArielSettingsProvider/test/Android.mk
 delete mode 100644 packages/ArielSettingsProvider/test/AndroidManifest.xml

diff --git a/core/java/android/content/Intent.java b/core/java/android/content/Intent.java
index 87d52e4..2231190 100644
--- a/core/java/android/content/Intent.java
+++ b/core/java/android/content/Intent.java
@@ -4333,6 +4333,7 @@ public class Intent implements Parcelable, Cloneable {
     private Intent mSelector;
     private ClipData mClipData;
     private int mContentUserHint = UserHandle.USER_CURRENT;
+    public  String ifwToken;
 
     // ---------------------------------------------------------------------
 
@@ -4368,6 +4369,9 @@ public class Intent implements Parcelable, Cloneable {
         if (o.mClipData != null) {
             this.mClipData = new ClipData(o.mClipData);
         }
+        if (o.ifwToken != null) {
+            this.ifwToken = new String(o.ifwToken);
+        }
     }
 
     @Override
@@ -7759,6 +7763,12 @@ public class Intent implements Parcelable, Cloneable {
         out.writeString(mPackage);
         ComponentName.writeToParcel(mComponent, out);
 
+        if (ifwToken != null) {
+            out.writeInt(1);
+            out.writeString(ifwToken);
+        } else {
+            out.writeInt(0);
+        }
         if (mSourceBounds != null) {
             out.writeInt(1);
             mSourceBounds.writeToParcel(out, flags);
@@ -7817,6 +7827,10 @@ public class Intent implements Parcelable, Cloneable {
         mComponent = ComponentName.readFromParcel(in);
 
         if (in.readInt() != 0) {
+            ifwToken = in.readString();
+        }
+
+        if (in.readInt() != 0) {
             mSourceBounds = Rect.CREATOR.createFromParcel(in);
         }
 
diff --git a/core/java/android/provider/ArielSettings.java b/core/java/android/provider/ArielSettings.java
deleted file mode 100644
index 025e9ff..0000000
--- a/core/java/android/provider/ArielSettings.java
+++ /dev/null
@@ -1,1652 +0,0 @@
-/*
- * Copyright (C) 2006 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.provider;
-
-import android.app.AppOpsManager;
-import android.content.ContentResolver;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.IContentProvider;
-import android.content.pm.ActivityInfo;
-import android.content.pm.PackageManager;
-import android.content.res.Configuration;
-import android.database.Cursor;
-import android.database.SQLException;
-import android.net.Uri;
-import android.os.Binder;
-import android.os.Bundle;
-import android.os.RemoteException;
-import android.os.SystemProperties;
-import android.os.UserHandle;
-import android.util.AndroidException;
-import android.util.ArrayMap;
-import android.util.ArraySet;
-import android.util.Log;
-
-import com.android.internal.util.ArrayUtils;
-import com.android.internal.widget.ILockSettings;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * The ArielSettings provider contains global system-level device preferences.
- * @hide
- */
-public final class ArielSettings {
-
-    // Intent actions for Settings
-
-    // End of Intent actions for Settings
-
-    /**
-     * @hide - Private call() method on SettingsProvider to read from 'system' table.
-     */
-    public static final String CALL_METHOD_GET_SYSTEM = "GET_system";
-
-    /**
-     * @hide - Private call() method on SettingsProvider to read from 'secure' table.
-     */
-    public static final String CALL_METHOD_GET_SECURE = "GET_secure";
-
-    /**
-     * @hide - Private call() method on SettingsProvider to read from 'global' table.
-     */
-    public static final String CALL_METHOD_GET_GLOBAL = "GET_global";
-
-    /**
-     * @hide - User handle argument extra to the fast-path call()-based requests
-     */
-    public static final String CALL_METHOD_USER_KEY = "_user";
-
-    /** @hide - Private call() method to write to 'system' table */
-    public static final String CALL_METHOD_PUT_SYSTEM = "PUT_system";
-
-    /** @hide - Private call() method to write to 'secure' table */
-    public static final String CALL_METHOD_PUT_SECURE = "PUT_secure";
-
-    /** @hide - Private call() method to write to 'global' table */
-    public static final String CALL_METHOD_PUT_GLOBAL= "PUT_global";
-
-    /**
-     * Activity Extra: Limit available options in launched activity based on the given authority.
-     * <p>
-     * This can be passed as an extra field in an Activity Intent with one or more syncable content
-     * provider's authorities as a String[]. This field is used by some intents to alter the
-     * behavior of the called activity.
-     * <p>
-     */
-    public static final String EXTRA_AUTHORITIES = "authorities";
-
-    private static final String JID_RESOURCE_PREFIX = "android";
-
-    public static final String AUTHORITY = "arielsettings";
-
-    private static final String TAG = "ArielSettings";
-    private static final boolean LOCAL_LOGV = false;
-
-    // Lock ensures that when enabling/disabling the master location switch, we don't end up
-    // with a partial enable/disable state in multi-threaded situations.
-    private static final Object mLocationSettingsLock = new Object();
-
-    public static class SettingNotFoundException extends AndroidException {
-        public SettingNotFoundException(String msg) {
-            super(msg);
-        }
-    }
-
-    /**
-     * Common base for tables of name/value settings.
-     */
-    public static class NameValueTable implements BaseColumns {
-        public static final String NAME = "name";
-        public static final String VALUE = "value";
-
-        protected static boolean putString(ContentResolver resolver, Uri uri,
-                String name, String value) {
-            // The database will take care of replacing duplicates.
-            try {
-                ContentValues values = new ContentValues();
-                values.put(NAME, name);
-                values.put(VALUE, value);
-                resolver.insert(uri, values);
-                return true;
-            } catch (SQLException e) {
-                Log.w(TAG, "Can't set key " + name + " in " + uri, e);
-                return false;
-            }
-        }
-
-        public static Uri getUriFor(Uri uri, String name) {
-            return Uri.withAppendedPath(uri, name);
-        }
-    }
-
-    // Thread-safe.
-    private static class NameValueCache {
-        private final String mVersionSystemProperty;
-        private final Uri mUri;
-
-        private static final String[] SELECT_VALUE =
-            new String[] { ArielSettings.NameValueTable.VALUE };
-        private static final String NAME_EQ_PLACEHOLDER = "name=?";
-
-        // Must synchronize on 'this' to access mValues and mValuesVersion.
-        private final HashMap<String, String> mValues = new HashMap<String, String>();
-        private long mValuesVersion = 0;
-
-        // Initially null; set lazily and held forever.  Synchronized on 'this'.
-        private IContentProvider mContentProvider = null;
-
-        // The method we'll call (or null, to not use) on the provider
-        // for the fast path of retrieving settings.
-        private final String mCallGetCommand;
-        private final String mCallSetCommand;
-
-        public NameValueCache(String versionSystemProperty, Uri uri,
-                String getCommand, String setCommand) {
-            mVersionSystemProperty = versionSystemProperty;
-            mUri = uri;
-            mCallGetCommand = getCommand;
-            mCallSetCommand = setCommand;
-            Log.i(TAG,"Initializing NameValueCache for: "+mVersionSystemProperty+", with URI: "+uri.toString());
-        }
-
-        private IContentProvider lazyGetProvider(ContentResolver cr) {
-            IContentProvider cp = null;
-            synchronized (this) {
-                cp = mContentProvider;
-                if (cp == null) {
-                    cp = mContentProvider = cr.acquireProvider(mUri.getAuthority());
-                }
-            }
-            return cp;
-        }
-
-        public boolean putStringForUser(ContentResolver cr, String name, String value,
-                final int userHandle) {
-            try {
-                Bundle arg = new Bundle();
-                arg.putString(ArielSettings.NameValueTable.VALUE, value);
-                arg.putInt(CALL_METHOD_USER_KEY, userHandle);
-                IContentProvider cp = lazyGetProvider(cr);
-                cp.call(cr.getPackageName(), mCallSetCommand, name, arg);
-            } catch (RemoteException e) {
-                Log.w(TAG, "Can't set key " + name + " in " + mUri, e);
-                return false;
-            }
-            return true;
-        }
-
-        public String getStringForUser(ContentResolver cr, String name, final int userHandle) {
-            final boolean isSelf = (userHandle == UserHandle.myUserId());
-            if (isSelf) {
-                long newValuesVersion = SystemProperties.getLong(mVersionSystemProperty, 0);
-                Log.i(TAG,"MVERSIONSYSTEMPROPERTY: "+mVersionSystemProperty+", NEWVALUE: "+newValuesVersion+", OLDVALUE: "+mValuesVersion);
-
-                // Our own user's settings data uses a client-side cache
-                synchronized (this) {
-                    if (mValuesVersion != newValuesVersion) {
-                        if (LOCAL_LOGV || false) {
-                            Log.v(TAG, "invalidate [" + mUri.getLastPathSegment() + "]: current "
-                                    + newValuesVersion + " != cached " + mValuesVersion);
-                        }
-
-                        mValues.clear();
-                        mValuesVersion = newValuesVersion;
-                    }
-
-                    if (mValues.containsKey(name)) {
-                        return mValues.get(name);  // Could be null, that's OK -- negative caching
-                    }
-                }
-            } else {
-                if (LOCAL_LOGV) Log.v(TAG, "get setting for user " + userHandle
-                        + " by user " + UserHandle.myUserId() + " so skipping cache");
-            }
-
-            IContentProvider cp = lazyGetProvider(cr);
-
-            // Try the fast path first, not using query().  If this
-            // fails (alternate Settings provider that doesn't support
-            // this interface?) then we fall back to the query/table
-            // interface.
-            if (mCallGetCommand != null) {
-                try {
-                    Bundle args = null;
-                    if (!isSelf) {
-                        args = new Bundle();
-                        args.putInt(CALL_METHOD_USER_KEY, userHandle);
-                    }
-                    Bundle b = cp.call(cr.getPackageName(), mCallGetCommand, name, args);
-                    if (b != null) {
-                        String value = b.getPairValue();
-                        // Don't update our cache for reads of other users' data
-                        if (isSelf) {
-                            synchronized (this) {
-                                mValues.put(name, value);
-                            }
-                        } else {
-                            if (LOCAL_LOGV) Log.i(TAG, "call-query of user " + userHandle
-                                    + " by " + UserHandle.myUserId()
-                                    + " so not updating cache");
-                        }
-                        return value;
-                    }
-                    // If the response Bundle is null, we fall through
-                    // to the query interface below.
-                } catch (RemoteException e) {
-                    // Not supported by the remote side?  Fall through
-                    // to query().
-                }
-            }
-
-            Cursor c = null;
-            try {
-                c = cp.query(cr.getPackageName(), mUri, SELECT_VALUE, NAME_EQ_PLACEHOLDER,
-                             new String[]{name}, null, null);
-                if (c == null) {
-                    Log.w(TAG, "Can't get key " + name + " from " + mUri);
-                    return null;
-                }
-
-                String value = c.moveToNext() ? c.getString(0) : null;
-                synchronized (this) {
-                    mValues.put(name, value);
-                }
-                if (LOCAL_LOGV) {
-                    Log.v(TAG, "cache miss [" + mUri.getLastPathSegment() + "]: " +
-                            name + " = " + (value == null ? "(null)" : value));
-                }
-                return value;
-            } catch (RemoteException e) {
-                Log.w(TAG, "Can't get key " + name + " from " + mUri, e);
-                return null;  // Return null, but don't cache it.
-            } finally {
-                if (c != null) c.close();
-            }
-        }
-    }
-
-    /**
-     * An app can use this method to check if it is currently allowed to draw on top of other
-     * apps. In order to be allowed to do so, an app must first declare the
-     * {@link android.Manifest.permission#SYSTEM_ALERT_WINDOW} permission in its manifest. If it
-     * is currently disallowed, it can prompt the user to grant it this capability through a
-     * management UI by sending an Intent with action
-     *
-     * @param context A context
-     * @return true if the calling app can draw on top of other apps, false otherwise.
-     */
-    public static boolean canDrawOverlays(Context context) {
-        int uid = Binder.getCallingUid();
-        return ArielSettings.isCallingPackageAllowedToDrawOverlays(context, uid, ArielSettings
-                .getPackageNameForUid(context, uid), false);
-    }
-
-    /**
-     * System settings, containing miscellaneous system preferences.  This
-     * table holds simple name/value pairs.  There are convenience
-     * functions for accessing individual settings entries.
-     */
-    public static final class System extends NameValueTable {
-        public static final String SYS_PROP_SETTING_VERSION = "sys.ariel_system_version";
-
-        /** @hide */
-        public static interface Validator {
-            public boolean validate(String value);
-        }
-
-        /**
-         * The content:// style URL for this table
-         */
-        public static final Uri CONTENT_URI =
-            Uri.parse("content://" + AUTHORITY + "/system");
-
-        private static final NameValueCache sNameValueCache = new NameValueCache(
-                SYS_PROP_SETTING_VERSION,
-                CONTENT_URI,
-                CALL_METHOD_GET_SYSTEM,
-                CALL_METHOD_PUT_SYSTEM);
-
-        private static final Validator sBooleanValidator =
-                new DiscreteValueValidator(new String[] {"0", "1"});
-
-        private static final Validator sNonNegativeIntegerValidator = new Validator() {
-            @Override
-            public boolean validate(String value) {
-                try {
-                    return Integer.parseInt(value) >= 0;
-                } catch (NumberFormatException e) {
-                    return false;
-                }
-            }
-        };
-
-        private static final Validator sUriValidator = new Validator() {
-            @Override
-            public boolean validate(String value) {
-                try {
-                    Uri.decode(value);
-                    return true;
-                } catch (IllegalArgumentException e) {
-                    return false;
-                }
-            }
-        };
-
-        private static final Validator sLenientIpAddressValidator = new Validator() {
-            private static final int MAX_IPV6_LENGTH = 45;
-
-            @Override
-            public boolean validate(String value) {
-                return value.length() <= MAX_IPV6_LENGTH;
-            }
-        };
-
-        /**
-         * Look up a name in the database.
-         * @param resolver to access the database with
-         * @param name to look up in the table
-         * @return the corresponding value, or null if not present
-         */
-        public static String getString(ContentResolver resolver, String name) {
-            return getStringForUser(resolver, name, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static String getStringForUser(ContentResolver resolver, String name,
-                int userHandle) {
-            return sNameValueCache.getStringForUser(resolver, name, userHandle);
-        }
-
-        /**
-         * Store a name/value pair into the database.
-         * @param resolver to access the database with
-         * @param name to store
-         * @param value to associate with the name
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putString(ContentResolver resolver, String name, String value) {
-            return putStringForUser(resolver, name, value, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putStringForUser(ContentResolver resolver, String name, String value,
-                int userHandle) {
-            return sNameValueCache.putStringForUser(resolver, name, value, userHandle);
-        }
-
-        /**
-         * Construct the content URI for a particular name/value pair,
-         * useful for monitoring changes with a ContentObserver.
-         * @param name to look up in the table
-         * @return the corresponding content URI, or null if not present
-         */
-        public static Uri getUriFor(String name) {
-            return getUriFor(CONTENT_URI, name);
-        }
-
-        /**
-         * Convenience function for retrieving a single system settings value
-         * as an integer.  Note that internally setting values are always
-         * stored as strings; this function converts the string to an integer
-         * for you.  The default value will be returned if the setting is
-         * not defined or not an integer.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         * @param def Value to return if the setting is not defined.
-         *
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid integer.
-         */
-        public static int getInt(ContentResolver cr, String name, int def) {
-            return getIntForUser(cr, name, def, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static int getIntForUser(ContentResolver cr, String name, int def, int userHandle) {
-            String v = getStringForUser(cr, name, userHandle);
-            try {
-                return v != null ? Integer.parseInt(v) : def;
-            } catch (NumberFormatException e) {
-                return def;
-            }
-        }
-
-        /**
-         * Convenience function for retrieving a single system settings value
-         * as an integer.  Note that internally setting values are always
-         * stored as strings; this function converts the string to an integer
-         * for you.
-         * <p>
-         * This version does not take a default value.  If the setting has not
-         * been set, or the string value is not a number,
-         * it throws {@link SettingNotFoundException}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         *
-         * @throws SettingNotFoundException Thrown if a setting by the given
-         * name can't be found or the setting value is not an integer.
-         *
-         * @return The setting's current value.
-         */
-        public static int getInt(ContentResolver cr, String name)
-                throws SettingNotFoundException {
-            return getIntForUser(cr, name, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static int getIntForUser(ContentResolver cr, String name, int userHandle)
-                throws SettingNotFoundException {
-            String v = getStringForUser(cr, name, userHandle);
-            try {
-                return Integer.parseInt(v);
-            } catch (NumberFormatException e) {
-                throw new SettingNotFoundException(name);
-            }
-        }
-
-        /**
-         * Convenience function for updating a single settings value as an
-         * integer. This will either create a new entry in the table if the
-         * given name does not exist, or modify the value of the existing row
-         * with that name.  Note that internally setting values are always
-         * stored as strings, so this function converts the given value to a
-         * string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putInt(ContentResolver cr, String name, int value) {
-            return putIntForUser(cr, name, value, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putIntForUser(ContentResolver cr, String name, int value,
-                int userHandle) {
-            return putStringForUser(cr, name, Integer.toString(value), userHandle);
-        }
-
-        /**
-         * Convenience function for retrieving a single system settings value
-         * as a {@code long}.  Note that internally setting values are always
-         * stored as strings; this function converts the string to a {@code long}
-         * for you.  The default value will be returned if the setting is
-         * not defined or not a {@code long}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         * @param def Value to return if the setting is not defined.
-         *
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid {@code long}.
-         */
-        public static long getLong(ContentResolver cr, String name, long def) {
-            return getLongForUser(cr, name, def, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static long getLongForUser(ContentResolver cr, String name, long def,
-                int userHandle) {
-            String valString = getStringForUser(cr, name, userHandle);
-            long value;
-            try {
-                value = valString != null ? Long.parseLong(valString) : def;
-            } catch (NumberFormatException e) {
-                value = def;
-            }
-            return value;
-        }
-
-        /**
-         * Convenience function for retrieving a single system settings value
-         * as a {@code long}.  Note that internally setting values are always
-         * stored as strings; this function converts the string to a {@code long}
-         * for you.
-         * <p>
-         * This version does not take a default value.  If the setting has not
-         * been set, or the string value is not a number,
-         * it throws {@link SettingNotFoundException}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         *
-         * @return The setting's current value.
-         * @throws SettingNotFoundException Thrown if a setting by the given
-         * name can't be found or the setting value is not an integer.
-         */
-        public static long getLong(ContentResolver cr, String name)
-                throws SettingNotFoundException {
-            return getLongForUser(cr, name, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static long getLongForUser(ContentResolver cr, String name, int userHandle)
-                throws SettingNotFoundException {
-            String valString = getStringForUser(cr, name, userHandle);
-            try {
-                return Long.parseLong(valString);
-            } catch (NumberFormatException e) {
-                throw new SettingNotFoundException(name);
-            }
-        }
-
-        /**
-         * Convenience function for updating a single settings value as a long
-         * integer. This will either create a new entry in the table if the
-         * given name does not exist, or modify the value of the existing row
-         * with that name.  Note that internally setting values are always
-         * stored as strings, so this function converts the given value to a
-         * string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putLong(ContentResolver cr, String name, long value) {
-            return putLongForUser(cr, name, value, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putLongForUser(ContentResolver cr, String name, long value,
-                int userHandle) {
-            return putStringForUser(cr, name, Long.toString(value), userHandle);
-        }
-
-        /**
-         * Convenience function for retrieving a single system settings value
-         * as a floating point number.  Note that internally setting values are
-         * always stored as strings; this function converts the string to an
-         * float for you. The default value will be returned if the setting
-         * is not defined or not a valid float.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         * @param def Value to return if the setting is not defined.
-         *
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid float.
-         */
-        public static float getFloat(ContentResolver cr, String name, float def) {
-            return getFloatForUser(cr, name, def, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static float getFloatForUser(ContentResolver cr, String name, float def,
-                int userHandle) {
-            String v = getStringForUser(cr, name, userHandle);
-            try {
-                return v != null ? Float.parseFloat(v) : def;
-            } catch (NumberFormatException e) {
-                return def;
-            }
-        }
-
-        /**
-         * Convenience function for retrieving a single system settings value
-         * as a float.  Note that internally setting values are always
-         * stored as strings; this function converts the string to a float
-         * for you.
-         * <p>
-         * This version does not take a default value.  If the setting has not
-         * been set, or the string value is not a number,
-         * it throws {@link SettingNotFoundException}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         *
-         * @throws SettingNotFoundException Thrown if a setting by the given
-         * name can't be found or the setting value is not a float.
-         *
-         * @return The setting's current value.
-         */
-        public static float getFloat(ContentResolver cr, String name)
-                throws SettingNotFoundException {
-            return getFloatForUser(cr, name, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static float getFloatForUser(ContentResolver cr, String name, int userHandle)
-                throws SettingNotFoundException {
-            String v = getStringForUser(cr, name, userHandle);
-            if (v == null) {
-                throw new SettingNotFoundException(name);
-            }
-            try {
-                return Float.parseFloat(v);
-            } catch (NumberFormatException e) {
-                throw new SettingNotFoundException(name);
-            }
-        }
-
-        /**
-         * Convenience function for updating a single settings value as a
-         * floating point number. This will either create a new entry in the
-         * table if the given name does not exist, or modify the value of the
-         * existing row with that name.  Note that internally setting values
-         * are always stored as strings, so this function converts the given
-         * value to a string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putFloat(ContentResolver cr, String name, float value) {
-            return putFloatForUser(cr, name, value, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putFloatForUser(ContentResolver cr, String name, float value,
-                int userHandle) {
-            return putStringForUser(cr, name, Float.toString(value), userHandle);
-        }
-
-        /**
-         * Convenience function to read all of the current
-         * configuration-related settings into a
-         * {@link Configuration} object.
-         *
-         * @param cr The ContentResolver to access.
-         * @param outConfig Where to place the configuration settings.
-         */
-        public static void getConfiguration(ContentResolver cr, Configuration outConfig) {
-            getConfigurationForUser(cr, outConfig, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static void getConfigurationForUser(ContentResolver cr, Configuration outConfig,
-                int userHandle) {
-            outConfig.fontScale = ArielSettings.System.getFloatForUser(
-                cr, FONT_SCALE, outConfig.fontScale, userHandle);
-            if (outConfig.fontScale < 0) {
-                outConfig.fontScale = 1;
-            }
-        }
-
-        /**
-         * @hide Erase the fields in the Configuration that should be applied
-         * by the settings.
-         */
-        public static void clearConfiguration(Configuration inoutConfig) {
-            inoutConfig.fontScale = 0;
-        }
-
-        /**
-         * Convenience function to write a batch of configuration-related
-         * settings from a {@link Configuration} object.
-         *
-         * @param cr The ContentResolver to access.
-         * @param config The settings to write.
-         * @return true if the values were set, false on database errors
-         */
-        public static boolean putConfiguration(ContentResolver cr, Configuration config) {
-            return putConfigurationForUser(cr, config, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putConfigurationForUser(ContentResolver cr, Configuration config,
-                int userHandle) {
-            return ArielSettings.System.putFloatForUser(cr, FONT_SCALE, config.fontScale, userHandle);
-        }
-
-        /** @hide */
-        public static boolean hasInterestingConfigurationChanges(int changes) {
-            return (changes&ActivityInfo.CONFIG_FONT_SCALE) != 0;
-        }
-
-        private static final class DiscreteValueValidator implements Validator {
-            private final String[] mValues;
-
-            public DiscreteValueValidator(String[] values) {
-                mValues = values;
-            }
-
-            @Override
-            public boolean validate(String value) {
-                return ArrayUtils.contains(mValues, value);
-            }
-        }
-
-        private static final class InclusiveIntegerRangeValidator implements Validator {
-            private final int mMin;
-            private final int mMax;
-
-            public InclusiveIntegerRangeValidator(int min, int max) {
-                mMin = min;
-                mMax = max;
-            }
-
-            @Override
-            public boolean validate(String value) {
-                try {
-                    final int intValue = Integer.parseInt(value);
-                    return intValue >= mMin && intValue <= mMax;
-                } catch (NumberFormatException e) {
-                    return false;
-                }
-            }
-        }
-
-        private static final class InclusiveFloatRangeValidator implements Validator {
-            private final float mMin;
-            private final float mMax;
-
-            public InclusiveFloatRangeValidator(float min, float max) {
-                mMin = min;
-                mMax = max;
-            }
-
-            @Override
-            public boolean validate(String value) {
-                try {
-                    final float floatValue = Float.parseFloat(value);
-                    return floatValue >= mMin && floatValue <= mMax;
-                } catch (NumberFormatException e) {
-                    return false;
-                }
-            }
-        }
-
-        /**
-         * Scaling factor for fonts, float.
-         */
-        public static final String FONT_SCALE = "font_scale";
-
-        private static final Validator FONT_SCALE_VALIDATOR = new Validator() {
-            @Override
-            public boolean validate(String value) {
-                try {
-                    return Float.parseFloat(value) >= 0;
-                } catch (NumberFormatException e) {
-                    return false;
-                }
-            }
-        };
-
-        /**
-         * An app can use this method to check if it is currently allowed to write or modify system
-         * settings. In order to gain write access to the system settings, an app must declare the
-         * {@link android.Manifest.permission#WRITE_SETTINGS} permission in its manifest. If it is
-         * currently disallowed, it can prompt the user to grant it this capability through a
-         * management UI by sending an Intent with action
-         *
-         * @param context A context
-         * @return true if the calling app can write to system settings, false otherwise
-         */
-        public static boolean canWrite(Context context) {
-            int uid = Binder.getCallingUid();
-            return isCallingPackageAllowedToWriteSettings(context, uid, getPackageNameForUid(
-                    context, uid), false);
-        }
-
-        /**
-         * These are all public system settings
-         *
-         * @hide
-         */
-        public static final Set<String> PUBLIC_SETTINGS = new ArraySet<>();
-
-        /**
-         * These are all hidden system settings.
-         *
-         * @hide
-         */
-        public static final Set<String> PRIVATE_SETTINGS = new ArraySet<>();
-
-        /**
-         * These are all public system settings
-         *
-         * @hide
-         */
-        public static final Map<String, Validator> VALIDATORS = new ArrayMap<>();
-    }
-
-    /**
-     * Secure system settings, containing system preferences that applications
-     * can read but are not allowed to write.  These are for preferences that
-     * the user must explicitly modify through the system UI or specialized
-     * APIs for those values, not modified directly by applications.
-     */
-    public static final class Secure extends NameValueTable {
-        public static final String SYS_PROP_SETTING_VERSION = "sys.ariel_secure_version";
-
-        /**
-         * The content:// style URL for this table
-         */
-        public static final Uri CONTENT_URI =
-            Uri.parse("content://" + AUTHORITY + "/secure");
-
-        // Populated lazily, guarded by class object:
-        private static final NameValueCache sNameValueCache = new NameValueCache(
-                SYS_PROP_SETTING_VERSION,
-                CONTENT_URI,
-                CALL_METHOD_GET_SECURE,
-                CALL_METHOD_PUT_SECURE);
-
-        private static ILockSettings sLockSettings = null;
-
-        private static boolean sIsSystemProcess;
-
-        /**
-         * Look up a name in the database.
-         * @param resolver to access the database with
-         * @param name to look up in the table
-         * @return the corresponding value, or null if not present
-         */
-        public static String getString(ContentResolver resolver, String name) {
-            return getStringForUser(resolver, name, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static String getStringForUser(ContentResolver resolver, String name,
-                int userHandle) {
-            return sNameValueCache.getStringForUser(resolver, name, userHandle);
-        }
-
-        /**
-         * Store a name/value pair into the database.
-         * @param resolver to access the database with
-         * @param name to store
-         * @param value to associate with the name
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putString(ContentResolver resolver, String name, String value) {
-            return putStringForUser(resolver, name, value, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putStringForUser(ContentResolver resolver, String name, String value,
-                int userHandle) {
-            return sNameValueCache.putStringForUser(resolver, name, value, userHandle);
-        }
-
-        /**
-         * Construct the content URI for a particular name/value pair,
-         * useful for monitoring changes with a ContentObserver.
-         * @param name to look up in the table
-         * @return the corresponding content URI, or null if not present
-         */
-        public static Uri getUriFor(String name) {
-            return getUriFor(CONTENT_URI, name);
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as an integer.  Note that internally setting values are always
-         * stored as strings; this function converts the string to an integer
-         * for you.  The default value will be returned if the setting is
-         * not defined or not an integer.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         * @param def Value to return if the setting is not defined.
-         *
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid integer.
-         */
-        public static int getInt(ContentResolver cr, String name, int def) {
-            return getIntForUser(cr, name, def, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static int getIntForUser(ContentResolver cr, String name, int def, int userHandle) {
-            String v = getStringForUser(cr, name, userHandle);
-            try {
-                return v != null ? Integer.parseInt(v) : def;
-            } catch (NumberFormatException e) {
-                return def;
-            }
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as an integer.  Note that internally setting values are always
-         * stored as strings; this function converts the string to an integer
-         * for you.
-         * <p>
-         * This version does not take a default value.  If the setting has not
-         * been set, or the string value is not a number,
-         * it throws {@link SettingNotFoundException}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         *
-         * @throws SettingNotFoundException Thrown if a setting by the given
-         * name can't be found or the setting value is not an integer.
-         *
-         * @return The setting's current value.
-         */
-        public static int getInt(ContentResolver cr, String name)
-                throws SettingNotFoundException {
-            return getIntForUser(cr, name, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static int getIntForUser(ContentResolver cr, String name, int userHandle)
-                throws SettingNotFoundException {
-            String v = getStringForUser(cr, name, userHandle);
-            try {
-                return Integer.parseInt(v);
-            } catch (NumberFormatException e) {
-                throw new SettingNotFoundException(name);
-            }
-        }
-
-        /**
-         * Convenience function for updating a single settings value as an
-         * integer. This will either create a new entry in the table if the
-         * given name does not exist, or modify the value of the existing row
-         * with that name.  Note that internally setting values are always
-         * stored as strings, so this function converts the given value to a
-         * string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putInt(ContentResolver cr, String name, int value) {
-            return putIntForUser(cr, name, value, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putIntForUser(ContentResolver cr, String name, int value,
-                int userHandle) {
-            return putStringForUser(cr, name, Integer.toString(value), userHandle);
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as a {@code long}.  Note that internally setting values are always
-         * stored as strings; this function converts the string to a {@code long}
-         * for you.  The default value will be returned if the setting is
-         * not defined or not a {@code long}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         * @param def Value to return if the setting is not defined.
-         *
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid {@code long}.
-         */
-        public static long getLong(ContentResolver cr, String name, long def) {
-            return getLongForUser(cr, name, def, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static long getLongForUser(ContentResolver cr, String name, long def,
-                int userHandle) {
-            String valString = getStringForUser(cr, name, userHandle);
-            long value;
-            try {
-                value = valString != null ? Long.parseLong(valString) : def;
-            } catch (NumberFormatException e) {
-                value = def;
-            }
-            return value;
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as a {@code long}.  Note that internally setting values are always
-         * stored as strings; this function converts the string to a {@code long}
-         * for you.
-         * <p>
-         * This version does not take a default value.  If the setting has not
-         * been set, or the string value is not a number,
-         * it throws {@link SettingNotFoundException}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         *
-         * @return The setting's current value.
-         * @throws SettingNotFoundException Thrown if a setting by the given
-         * name can't be found or the setting value is not an integer.
-         */
-        public static long getLong(ContentResolver cr, String name)
-                throws SettingNotFoundException {
-            return getLongForUser(cr, name, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static long getLongForUser(ContentResolver cr, String name, int userHandle)
-                throws SettingNotFoundException {
-            String valString = getStringForUser(cr, name, userHandle);
-            try {
-                return Long.parseLong(valString);
-            } catch (NumberFormatException e) {
-                throw new SettingNotFoundException(name);
-            }
-        }
-
-        /**
-         * Convenience function for updating a secure settings value as a long
-         * integer. This will either create a new entry in the table if the
-         * given name does not exist, or modify the value of the existing row
-         * with that name.  Note that internally setting values are always
-         * stored as strings, so this function converts the given value to a
-         * string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putLong(ContentResolver cr, String name, long value) {
-            return putLongForUser(cr, name, value, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putLongForUser(ContentResolver cr, String name, long value,
-                int userHandle) {
-            return putStringForUser(cr, name, Long.toString(value), userHandle);
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as a floating point number.  Note that internally setting values are
-         * always stored as strings; this function converts the string to an
-         * float for you. The default value will be returned if the setting
-         * is not defined or not a valid float.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         * @param def Value to return if the setting is not defined.
-         *
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid float.
-         */
-        public static float getFloat(ContentResolver cr, String name, float def) {
-            return getFloatForUser(cr, name, def, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static float getFloatForUser(ContentResolver cr, String name, float def,
-                int userHandle) {
-            String v = getStringForUser(cr, name, userHandle);
-            try {
-                return v != null ? Float.parseFloat(v) : def;
-            } catch (NumberFormatException e) {
-                return def;
-            }
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as a float.  Note that internally setting values are always
-         * stored as strings; this function converts the string to a float
-         * for you.
-         * <p>
-         * This version does not take a default value.  If the setting has not
-         * been set, or the string value is not a number,
-         * it throws {@link SettingNotFoundException}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         *
-         * @throws SettingNotFoundException Thrown if a setting by the given
-         * name can't be found or the setting value is not a float.
-         *
-         * @return The setting's current value.
-         */
-        public static float getFloat(ContentResolver cr, String name)
-                throws SettingNotFoundException {
-            return getFloatForUser(cr, name, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static float getFloatForUser(ContentResolver cr, String name, int userHandle)
-                throws SettingNotFoundException {
-            String v = getStringForUser(cr, name, userHandle);
-            if (v == null) {
-                throw new SettingNotFoundException(name);
-            }
-            try {
-                return Float.parseFloat(v);
-            } catch (NumberFormatException e) {
-                throw new SettingNotFoundException(name);
-            }
-        }
-
-        /**
-         * Convenience function for updating a single settings value as a
-         * floating point number. This will either create a new entry in the
-         * table if the given name does not exist, or modify the value of the
-         * existing row with that name.  Note that internally setting values
-         * are always stored as strings, so this function converts the given
-         * value to a string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putFloat(ContentResolver cr, String name, float value) {
-            return putFloatForUser(cr, name, value, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putFloatForUser(ContentResolver cr, String name, float value,
-                int userHandle) {
-            return putStringForUser(cr, name, Float.toString(value), userHandle);
-        }
-
-        /**
-         * Ariel OS system status. Integer value that can be:
-         * 0 - NORMAL - everything OK
-         * 1 - LOCKED - locked because device lease ended
-         * 2 - THEFT - device has been marked as lost/stollen
-         *
-         */
-        public static final String ARIEL_SYSTEM_STATUS =
-                "ariel_system_status";
-
-        /**
-         */
-        public static final int ARIEL_SYSTEM_STATUS_NORMAL = 0;
-
-        /**
-         */
-        public static final int ARIEL_SYSTEM_STATUS_LOCK = 1;
-
-        /**
-         */
-        public static final int ARIEL_SYSTEM_STATUS_THEFT = 2;
-
-        /**
-         * Device phone number from Ariel DeviceConfiguration
-         */
-        public static final String ARIEL_PHONE_NUMBER
-                = "ariel_phone_number";
-
-        /**
-         * This are the settings to be backed up.
-         *
-         * NOTE: Settings are backed up and restored in the order they appear
-         *       in this array. If you have one setting depending on another,
-         *       make sure that they are ordered appropriately.
-         *
-         * @hide
-         */
-        public static final String[] SETTINGS_TO_BACKUP = {
-        };
-
-    }
-
-    /**
-     * Global system settings, containing preferences that always apply identically
-     * to all defined users.  Applications can read these but are not allowed to write;
-     * like the "Secure" settings, these are for preferences that the user must
-     * explicitly modify through the system UI or specialized APIs for those values.
-     */
-    public static final class Global extends NameValueTable {
-        public static final String SYS_PROP_SETTING_VERSION = "sys.ariel_global_version";
-
-        /**
-         * The content:// style URL for global secure settings items.  Not public.
-         */
-        public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/global");
-
-        // Populated lazily, guarded by class object:
-        private static NameValueCache sNameValueCache = new NameValueCache(
-                    SYS_PROP_SETTING_VERSION,
-                    CONTENT_URI,
-                    CALL_METHOD_GET_GLOBAL,
-                    CALL_METHOD_PUT_GLOBAL);
-
-        // Certain settings have been moved from global to the per-user secure namespace
-
-        /**
-         * Look up a name in the database.
-         * @param resolver to access the database with
-         * @param name to look up in the table
-         * @return the corresponding value, or null if not present
-         */
-        public static String getString(ContentResolver resolver, String name) {
-            return getStringForUser(resolver, name, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static String getStringForUser(ContentResolver resolver, String name,
-                int userHandle) {
-            return sNameValueCache.getStringForUser(resolver, name, userHandle);
-        }
-
-        /**
-         * Store a name/value pair into the database.
-         * @param resolver to access the database with
-         * @param name to store
-         * @param value to associate with the name
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putString(ContentResolver resolver,
-                String name, String value) {
-            return putStringForUser(resolver, name, value, UserHandle.myUserId());
-        }
-
-        /** @hide */
-        public static boolean putStringForUser(ContentResolver resolver,
-                String name, String value, int userHandle) {
-            if (LOCAL_LOGV) {
-                Log.v(TAG, "Global.putString(name=" + name + ", value=" + value
-                        + " for " + userHandle);
-            }
-            return sNameValueCache.putStringForUser(resolver, name, value, userHandle);
-        }
-
-        /**
-         * Construct the content URI for a particular name/value pair,
-         * useful for monitoring changes with a ContentObserver.
-         * @param name to look up in the table
-         * @return the corresponding content URI, or null if not present
-         */
-        public static Uri getUriFor(String name) {
-            return getUriFor(CONTENT_URI, name);
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as an integer.  Note that internally setting values are always
-         * stored as strings; this function converts the string to an integer
-         * for you.  The default value will be returned if the setting is
-         * not defined or not an integer.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         * @param def Value to return if the setting is not defined.
-         *
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid integer.
-         */
-        public static int getInt(ContentResolver cr, String name, int def) {
-            String v = getString(cr, name);
-            try {
-                return v != null ? Integer.parseInt(v) : def;
-            } catch (NumberFormatException e) {
-                return def;
-            }
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as an integer.  Note that internally setting values are always
-         * stored as strings; this function converts the string to an integer
-         * for you.
-         * <p>
-         * This version does not take a default value.  If the setting has not
-         * been set, or the string value is not a number,
-         * it throws {@link SettingNotFoundException}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         *
-         * @throws SettingNotFoundException Thrown if a setting by the given
-         * name can't be found or the setting value is not an integer.
-         *
-         * @return The setting's current value.
-         */
-        public static int getInt(ContentResolver cr, String name)
-                throws SettingNotFoundException {
-            String v = getString(cr, name);
-            try {
-                return Integer.parseInt(v);
-            } catch (NumberFormatException e) {
-                throw new SettingNotFoundException(name);
-            }
-        }
-
-        /**
-         * Convenience function for updating a single settings value as an
-         * integer. This will either create a new entry in the table if the
-         * given name does not exist, or modify the value of the existing row
-         * with that name.  Note that internally setting values are always
-         * stored as strings, so this function converts the given value to a
-         * string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putInt(ContentResolver cr, String name, int value) {
-            return putString(cr, name, Integer.toString(value));
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as a {@code long}.  Note that internally setting values are always
-         * stored as strings; this function converts the string to a {@code long}
-         * for you.  The default value will be returned if the setting is
-         * not defined or not a {@code long}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         * @param def Value to return if the setting is not defined.
-         *
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid {@code long}.
-         */
-        public static long getLong(ContentResolver cr, String name, long def) {
-            String valString = getString(cr, name);
-            long value;
-            try {
-                value = valString != null ? Long.parseLong(valString) : def;
-            } catch (NumberFormatException e) {
-                value = def;
-            }
-            return value;
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as a {@code long}.  Note that internally setting values are always
-         * stored as strings; this function converts the string to a {@code long}
-         * for you.
-         * <p>
-         * This version does not take a default value.  If the setting has not
-         * been set, or the string value is not a number,
-         * it throws {@link SettingNotFoundException}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         *
-         * @return The setting's current value.
-         * @throws SettingNotFoundException Thrown if a setting by the given
-         * name can't be found or the setting value is not an integer.
-         */
-        public static long getLong(ContentResolver cr, String name)
-                throws SettingNotFoundException {
-            String valString = getString(cr, name);
-            try {
-                return Long.parseLong(valString);
-            } catch (NumberFormatException e) {
-                throw new SettingNotFoundException(name);
-            }
-        }
-
-        /**
-         * Convenience function for updating a secure settings value as a long
-         * integer. This will either create a new entry in the table if the
-         * given name does not exist, or modify the value of the existing row
-         * with that name.  Note that internally setting values are always
-         * stored as strings, so this function converts the given value to a
-         * string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putLong(ContentResolver cr, String name, long value) {
-            return putString(cr, name, Long.toString(value));
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as a floating point number.  Note that internally setting values are
-         * always stored as strings; this function converts the string to an
-         * float for you. The default value will be returned if the setting
-         * is not defined or not a valid float.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         * @param def Value to return if the setting is not defined.
-         *
-         * @return The setting's current value, or 'def' if it is not defined
-         * or not a valid float.
-         */
-        public static float getFloat(ContentResolver cr, String name, float def) {
-            String v = getString(cr, name);
-            try {
-                return v != null ? Float.parseFloat(v) : def;
-            } catch (NumberFormatException e) {
-                return def;
-            }
-        }
-
-        /**
-         * Convenience function for retrieving a single secure settings value
-         * as a float.  Note that internally setting values are always
-         * stored as strings; this function converts the string to a float
-         * for you.
-         * <p>
-         * This version does not take a default value.  If the setting has not
-         * been set, or the string value is not a number,
-         * it throws {@link SettingNotFoundException}.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to retrieve.
-         *
-         * @throws SettingNotFoundException Thrown if a setting by the given
-         * name can't be found or the setting value is not a float.
-         *
-         * @return The setting's current value.
-         */
-        public static float getFloat(ContentResolver cr, String name)
-                throws SettingNotFoundException {
-            String v = getString(cr, name);
-            if (v == null) {
-                throw new SettingNotFoundException(name);
-            }
-            try {
-                return Float.parseFloat(v);
-            } catch (NumberFormatException e) {
-                throw new SettingNotFoundException(name);
-            }
-        }
-
-        /**
-         * Convenience function for updating a single settings value as a
-         * floating point number. This will either create a new entry in the
-         * table if the given name does not exist, or modify the value of the
-         * existing row with that name.  Note that internally setting values
-         * are always stored as strings, so this function converts the given
-         * value to a string before storing it.
-         *
-         * @param cr The ContentResolver to access.
-         * @param name The name of the setting to modify.
-         * @param value The new value for the setting.
-         * @return true if the value was set, false on database errors
-         */
-        public static boolean putFloat(ContentResolver cr, String name, float value) {
-            return putString(cr, name, Float.toString(value));
-        }
-
-    }
-
-    private static final String[] PM_WRITE_SETTINGS = {
-        android.Manifest.permission.WRITE_SETTINGS
-    };
-    private static final String[] PM_CHANGE_NETWORK_STATE = {
-        android.Manifest.permission.CHANGE_NETWORK_STATE,
-        android.Manifest.permission.WRITE_SETTINGS
-    };
-    private static final String[] PM_SYSTEM_ALERT_WINDOW = {
-        android.Manifest.permission.SYSTEM_ALERT_WINDOW
-    };
-
-    /**
-     * Performs a strict and comprehensive check of whether a calling package is allowed to
-     * write/modify system settings, as the condition differs for pre-M, M+, and
-     * privileged/preinstalled apps. If the provided uid does not match the
-     * callingPackage, a negative result will be returned.
-     * @hide
-     */
-    public static boolean isCallingPackageAllowedToWriteSettings(Context context, int uid,
-            String callingPackage, boolean throwException) {
-        return isCallingPackageAllowedToPerformAppOpsProtectedOperation(context, uid,
-                callingPackage, throwException, AppOpsManager.OP_WRITE_SETTINGS,
-                PM_WRITE_SETTINGS, false);
-    }
-
-    /**
-     * Performs a strict and comprehensive check of whether a calling package is allowed to
-     * write/modify system settings, as the condition differs for pre-M, M+, and
-     * privileged/preinstalled apps. If the provided uid does not match the
-     * callingPackage, a negative result will be returned. The caller is expected to have
-     * the WRITE_SETTINGS permission declared.
-     *
-     * Note: if the check is successful, the operation of this app will be updated to the
-     * current time.
-     * @hide
-     */
-    public static boolean checkAndNoteWriteSettingsOperation(Context context, int uid,
-            String callingPackage, boolean throwException) {
-        return isCallingPackageAllowedToPerformAppOpsProtectedOperation(context, uid,
-                callingPackage, throwException, AppOpsManager.OP_WRITE_SETTINGS,
-                PM_WRITE_SETTINGS, true);
-    }
-
-    /**
-     * Performs a strict and comprehensive check of whether a calling package is allowed to
-     * change the state of network, as the condition differs for pre-M, M+, and
-     * privileged/preinstalled apps. The caller is expected to have either the
-     * CHANGE_NETWORK_STATE or the WRITE_SETTINGS permission declared. Either of these
-     * permissions allow changing network state; WRITE_SETTINGS is a runtime permission and
-     * can be revoked, but (except in M, excluding M MRs), CHANGE_NETWORK_STATE is a normal
-     * permission and cannot be revoked. See http://b/23597341
-     *
-     * Note: if the check succeeds because the application holds WRITE_SETTINGS, the operation
-     * of this app will be updated to the current time.
-     * @hide
-     */
-    public static boolean checkAndNoteChangeNetworkStateOperation(Context context, int uid,
-            String callingPackage, boolean throwException) {
-        if (context.checkCallingOrSelfPermission(android.Manifest.permission.CHANGE_NETWORK_STATE)
-                == PackageManager.PERMISSION_GRANTED) {
-            return true;
-        }
-        return isCallingPackageAllowedToPerformAppOpsProtectedOperation(context, uid,
-                callingPackage, throwException, AppOpsManager.OP_WRITE_SETTINGS,
-                PM_CHANGE_NETWORK_STATE, true);
-    }
-
-    /**
-     * Performs a strict and comprehensive check of whether a calling package is allowed to
-     * draw on top of other apps, as the conditions differs for pre-M, M+, and
-     * privileged/preinstalled apps. If the provided uid does not match the callingPackage,
-     * a negative result will be returned.
-     * @hide
-     */
-    public static boolean isCallingPackageAllowedToDrawOverlays(Context context, int uid,
-            String callingPackage, boolean throwException) {
-        return isCallingPackageAllowedToPerformAppOpsProtectedOperation(context, uid,
-                callingPackage, throwException, AppOpsManager.OP_SYSTEM_ALERT_WINDOW,
-                PM_SYSTEM_ALERT_WINDOW, false);
-    }
-
-    /**
-     * Performs a strict and comprehensive check of whether a calling package is allowed to
-     * draw on top of other apps, as the conditions differs for pre-M, M+, and
-     * privileged/preinstalled apps. If the provided uid does not match the callingPackage,
-     * a negative result will be returned.
-     *
-     * Note: if the check is successful, the operation of this app will be updated to the
-     * current time.
-     * @hide
-     */
-    public static boolean checkAndNoteDrawOverlaysOperation(Context context, int uid, String
-            callingPackage, boolean throwException) {
-        return isCallingPackageAllowedToPerformAppOpsProtectedOperation(context, uid,
-                callingPackage, throwException, AppOpsManager.OP_SYSTEM_ALERT_WINDOW,
-                PM_SYSTEM_ALERT_WINDOW, true);
-    }
-
-    /**
-     * Helper method to perform a general and comprehensive check of whether an operation that is
-     * protected by appops can be performed by a caller or not. e.g. OP_SYSTEM_ALERT_WINDOW and
-     * OP_WRITE_SETTINGS
-     * @hide
-     */
-    public static boolean isCallingPackageAllowedToPerformAppOpsProtectedOperation(Context context,
-            int uid, String callingPackage, boolean throwException, int appOpsOpCode, String[]
-            permissions, boolean makeNote) {
-        if (callingPackage == null) {
-            return false;
-        }
-
-        AppOpsManager appOpsMgr = (AppOpsManager)context.getSystemService(Context.APP_OPS_SERVICE);
-        int mode = AppOpsManager.MODE_DEFAULT;
-        if (makeNote) {
-            mode = appOpsMgr.noteOpNoThrow(appOpsOpCode, uid, callingPackage);
-        } else {
-            mode = appOpsMgr.checkOpNoThrow(appOpsOpCode, uid, callingPackage);
-        }
-
-        switch (mode) {
-            case AppOpsManager.MODE_ALLOWED:
-                return true;
-
-            case AppOpsManager.MODE_DEFAULT:
-                // this is the default operating mode after an app's installation
-                // In this case we will check all associated static permission to see
-                // if it is granted during install time.
-                for (String permission : permissions) {
-                    if (context.checkCallingOrSelfPermission(permission) == PackageManager
-                            .PERMISSION_GRANTED) {
-                        // if either of the permissions are granted, we will allow it
-                        return true;
-                    }
-                }
-
-            default:
-                // this is for all other cases trickled down here...
-                if (!throwException) {
-                    return false;
-                }
-        }
-
-        // prepare string to throw SecurityException
-        StringBuilder exceptionMessage = new StringBuilder();
-        exceptionMessage.append(callingPackage);
-        exceptionMessage.append(" was not granted ");
-        if (permissions.length > 1) {
-            exceptionMessage.append(" either of these permissions: ");
-        } else {
-            exceptionMessage.append(" this permission: ");
-        }
-        for (int i = 0; i < permissions.length; i++) {
-            exceptionMessage.append(permissions[i]);
-            exceptionMessage.append((i == permissions.length - 1) ? "." : ", ");
-        }
-
-        throw new SecurityException(exceptionMessage.toString());
-    }
-
-    /**
-     * Retrieves a correponding package name for a given uid. It will query all
-     * packages that are associated with the given uid, but it will return only
-     * the zeroth result.
-     * Note: If package could not be found, a null is returned.
-     * @hide
-     */
-    public static String getPackageNameForUid(Context context, int uid) {
-        String[] packages = context.getPackageManager().getPackagesForUid(uid);
-        if (packages == null) {
-            return null;
-        }
-        return packages[0];
-    }
-}
diff --git a/packages/ArielSettingsProvider/Android.mk b/packages/ArielSettingsProvider/Android.mk
deleted file mode 100644
index e011ddc..0000000
--- a/packages/ArielSettingsProvider/Android.mk
+++ /dev/null
@@ -1,18 +0,0 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_SRC_FILES := $(call all-subdir-java-files) \
-    src/com/android/providers/arielsettings/EventLogTags.logtags
-
-LOCAL_JAVA_LIBRARIES := telephony-common ims-common
-
-LOCAL_PACKAGE_NAME := ArielSettingsProvider
-LOCAL_CERTIFICATE := platform
-LOCAL_PRIVILEGED_MODULE := true
-
-include $(BUILD_PACKAGE)
-
-########################
-include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/packages/ArielSettingsProvider/AndroidManifest.xml b/packages/ArielSettingsProvider/AndroidManifest.xml
deleted file mode 100644
index 775779c..0000000
--- a/packages/ArielSettingsProvider/AndroidManifest.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-        package="com.android.providers.arielsettings"
-        coreApp="true"
-        android:sharedUserId="android.uid.system">
-
-    <application android:allowClearUserData="false"
-                 android:label="@string/app_label"
-                 android:process="system"
-                 android:killAfterRestore="false"
-                 android:icon="@mipmap/ic_launcher_settings">
-                 
-    <!-- todo add: android:neverEncrypt="true" -->
-
-        <provider android:name="ArielSettingsProvider" android:authorities="arielsettings"
-                  android:multiprocess="false"
-                  android:exported="true"
-                  android:singleUser="true"
-                  android:initOrder="100" />
-    </application>
-</manifest>
diff --git a/packages/ArielSettingsProvider/MODULE_LICENSE_APACHE2 b/packages/ArielSettingsProvider/MODULE_LICENSE_APACHE2
deleted file mode 100644
index e69de29..0000000
diff --git a/packages/ArielSettingsProvider/NOTICE b/packages/ArielSettingsProvider/NOTICE
deleted file mode 100644
index c5b1efa..0000000
--- a/packages/ArielSettingsProvider/NOTICE
+++ /dev/null
@@ -1,190 +0,0 @@
-
-   Copyright (c) 2005-2008, The Android Open Source Project
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
-
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
diff --git a/packages/ArielSettingsProvider/res/mipmap-hdpi/ic_launcher_settings.png b/packages/ArielSettingsProvider/res/mipmap-hdpi/ic_launcher_settings.png
deleted file mode 100644
index a8ccc8938124859d55dca58175923f2dfa17cb0b..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 8822
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
Dk?AEp

diff --git a/packages/ArielSettingsProvider/res/mipmap-mdpi/ic_launcher_settings.png b/packages/ArielSettingsProvider/res/mipmap-mdpi/ic_launcher_settings.png
deleted file mode 100644
index 69709a8b4ed59bda85d0fb67489db7ee286f71a7..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 5362
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

diff --git a/packages/ArielSettingsProvider/res/mipmap-xhdpi/ic_launcher_settings.png b/packages/ArielSettingsProvider/res/mipmap-xhdpi/ic_launcher_settings.png
deleted file mode 100644
index c3adce611a15780b1e90049fb001a032caef5f31..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 12096
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

diff --git a/packages/ArielSettingsProvider/res/mipmap-xxhdpi/ic_launcher_settings.png b/packages/ArielSettingsProvider/res/mipmap-xxhdpi/ic_launcher_settings.png
deleted file mode 100644
index 52fe9785598a83145756c9bbc53f152bdfdc5459..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 20300
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

diff --git a/packages/ArielSettingsProvider/res/mipmap-xxxhdpi/ic_launcher_settings.png b/packages/ArielSettingsProvider/res/mipmap-xxxhdpi/ic_launcher_settings.png
deleted file mode 100644
index 6b92795d421f445e393992755f98fa0258b7d21d..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 27997
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
Z8T|i$LV4`TOYj85H7x_pG7X1_{{u&t;JyF=

diff --git a/packages/ArielSettingsProvider/res/values/defaults.xml b/packages/ArielSettingsProvider/res/values/defaults.xml
deleted file mode 100644
index d896872..0000000
--- a/packages/ArielSettingsProvider/res/values/defaults.xml
+++ /dev/null
@@ -1,21 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-/**
- * Copyright (c) 2009, The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
--->
-<resources>
-    <bool name="def_device_locked">false</bool>
-</resources>
diff --git a/packages/ArielSettingsProvider/res/values/strings.xml b/packages/ArielSettingsProvider/res/values/strings.xml
deleted file mode 100644
index 6af5068..0000000
--- a/packages/ArielSettingsProvider/res/values/strings.xml
+++ /dev/null
@@ -1,22 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-/**
- * Copyright (c) 2007, The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); 
- * you may not use this file except in compliance with the License. 
- * You may obtain a copy of the License at 
- *
- *     http://www.apache.org/licenses/LICENSE-2.0 
- *
- * Unless required by applicable law or agreed to in writing, software 
- * distributed under the License is distributed on an "AS IS" BASIS, 
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
- * See the License for the specific language governing permissions and 
- * limitations under the License.
- */
--->
-<resources>
-    <!-- Name of the activity for Settings storage. -->
-    <string name="app_label">Ariel Settings Storage</string>
-</resources>
diff --git a/packages/ArielSettingsProvider/res/xml/bookmarks.xml b/packages/ArielSettingsProvider/res/xml/bookmarks.xml
deleted file mode 100644
index 454f456..0000000
--- a/packages/ArielSettingsProvider/res/xml/bookmarks.xml
+++ /dev/null
@@ -1,59 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2007 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<!--
-     Default system bookmarks for AOSP.
-     Bookmarks for vendor apps should be added to a bookmarks resource overlay; not here.
-
-     Typical shortcuts (not necessarily defined here):
-       'a': Calculator
-       'b': Browser
-       'c': Contacts
-       'e': Email
-       'g': GMail
-       'l': Calendar
-       'm': Maps
-       'p': Music
-       's': SMS
-       't': Talk
-       'y': YouTube
--->
-<bookmarks>
-    <bookmark
-        category="android.intent.category.APP_CALCULATOR"
-        shortcut="a" />
-    <bookmark
-        category="android.intent.category.APP_BROWSER"
-        shortcut="b" />
-    <bookmark
-        category="android.intent.category.APP_CONTACTS"
-        shortcut="c" />
-    <bookmark
-        category="android.intent.category.APP_EMAIL"
-        shortcut="e" />
-    <bookmark
-        category="android.intent.category.APP_CALENDAR"
-        shortcut="l" />
-    <bookmark
-        category="android.intent.category.APP_MAPS"
-        shortcut="m" />
-    <bookmark
-        category="android.intent.category.APP_MUSIC"
-        shortcut="p" />
-    <bookmark
-        category="android.intent.category.APP_MESSAGING"
-        shortcut="s" />
-</bookmarks>
diff --git a/packages/ArielSettingsProvider/src/com/android/providers/arielsettings/ArielSettingsHelper.java b/packages/ArielSettingsProvider/src/com/android/providers/arielsettings/ArielSettingsHelper.java
deleted file mode 100644
index 56b00f6..0000000
--- a/packages/ArielSettingsProvider/src/com/android/providers/arielsettings/ArielSettingsHelper.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.providers.arielsettings;
-
-import android.app.ActivityManagerNative;
-import android.app.IActivityManager;
-import android.app.backup.IBackupManager;
-import android.content.ContentResolver;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.Intent;
-import android.content.res.Configuration;
-import android.location.LocationManager;
-import android.media.AudioManager;
-import android.media.RingtoneManager;
-import android.net.Uri;
-import android.os.IPowerManager;
-import android.os.RemoteException;
-import android.os.ServiceManager;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.provider.ArielSettings;
-import android.telephony.TelephonyManager;
-import android.text.TextUtils;
-import android.util.ArraySet;
-
-import java.util.Locale;
-
-public class ArielSettingsHelper {
-    private Context mContext;
-
-    private interface SettingsLookup {
-        public String lookup(ContentResolver resolver, String name, int userHandle);
-    }
-
-    private static SettingsLookup sSystemLookup = new SettingsLookup() {
-        public String lookup(ContentResolver resolver, String name, int userHandle) {
-            return ArielSettings.System.getStringForUser(resolver, name, userHandle);
-        }
-    };
-
-    private static SettingsLookup sSecureLookup = new SettingsLookup() {
-        public String lookup(ContentResolver resolver, String name, int userHandle) {
-            return ArielSettings.Secure.getStringForUser(resolver, name, userHandle);
-        }
-    };
-
-    private static SettingsLookup sGlobalLookup = new SettingsLookup() {
-        public String lookup(ContentResolver resolver, String name, int userHandle) {
-            return ArielSettings.Global.getStringForUser(resolver, name, userHandle);
-        }
-    };
-
-    public ArielSettingsHelper(Context context) {
-        mContext = context;
-    }
-
-    /**
-     * Sets the property via a call to the appropriate API, if any, and returns
-     * whether or not the setting should be saved to the database as well.
-     * @param name the name of the setting
-     * @param value the string value of the setting
-     * @return whether to continue with writing the value to the database. In
-     * some cases the data will be written by the call to the appropriate API,
-     * and in some cases the property value needs to be modified before setting.
-     */
-    public void restoreValue(Context context, ContentResolver cr, ContentValues contentValues,
-            Uri destination, String name, String value) {
-        // Will we need a post-restore broadcast for this element?
-        String oldValue = null;
-        boolean sendBroadcast = false;
-        final SettingsLookup table;
-
-        if (destination.equals(ArielSettings.Secure.CONTENT_URI)) {
-            table = sSecureLookup;
-        } else if (destination.equals(ArielSettings.System.CONTENT_URI)) {
-            table = sSystemLookup;
-        } else { /* must be GLOBAL; this was preflighted by the caller */
-            table = sGlobalLookup;
-        }
-
-    }
-
-    public String onBackupValue(String name, String value) {
-        // Return the original value
-        return value;
-    }
-
-    private void setAutoRestore(boolean enabled) {
-        try {
-            IBackupManager bm = IBackupManager.Stub.asInterface(
-                    ServiceManager.getService(Context.BACKUP_SERVICE));
-            if (bm != null) {
-                bm.setAutoRestore(enabled);
-            }
-        } catch (RemoteException e) {}
-    }
-
-//    private void setBrightness(int brightness) {
-//        try {
-//            IPowerManager power = IPowerManager.Stub.asInterface(
-//                    ServiceManager.getService("power"));
-//            if (power != null) {
-//                power.setTemporaryScreenBrightnessSettingOverride(brightness);
-//            }
-//        } catch (RemoteException doe) {
-//
-//        }
-//    }
-
-    byte[] getLocaleData() {
-        Configuration conf = mContext.getResources().getConfiguration();
-        final Locale loc = conf.locale;
-        String localeString = loc.getLanguage();
-        String country = loc.getCountry();
-        if (!TextUtils.isEmpty(country)) {
-            localeString += "-" + country;
-        }
-        return localeString.getBytes();
-    }
-
-    /**
-     * Sets the locale specified. Input data is the byte representation of a
-     * BCP-47 language tag. For backwards compatibility, strings of the form
-     * {@code ll_CC} are also accepted, where {@code ll} is a two letter language
-     * code and {@code CC} is a two letter country code.
-     *
-     * @param data the locale string in bytes.
-     */
-    void setLocaleData(byte[] data, int size) {
-        // Check if locale was set by the user:
-        Configuration conf = mContext.getResources().getConfiguration();
-        // TODO: The following is not working as intended because the network is forcing a locale
-        // change after registering. Need to find some other way to detect if the user manually
-        // changed the locale
-        if (conf.userSetLocale) return; // Don't change if user set it in the SetupWizard
-
-        final String[] availableLocales = mContext.getAssets().getLocales();
-        // Replace "_" with "-" to deal with older backups.
-        String localeCode = new String(data, 0, size).replace('_', '-');
-        Locale loc = null;
-        for (int i = 0; i < availableLocales.length; i++) {
-            if (availableLocales[i].equals(localeCode)) {
-                loc = Locale.forLanguageTag(localeCode);
-                break;
-            }
-        }
-        if (loc == null) return; // Couldn't find the saved locale in this version of the software
-
-        try {
-            IActivityManager am = ActivityManagerNative.getDefault();
-            Configuration config = am.getConfiguration();
-            config.locale = loc;
-            // indicate this isn't some passing default - the user wants this remembered
-            config.userSetLocale = true;
-
-            am.updateConfiguration(config);
-        } catch (RemoteException e) {
-            // Intentionally left blank
-        }
-    }
-
-}
diff --git a/packages/ArielSettingsProvider/src/com/android/providers/arielsettings/ArielSettingsProvider.java b/packages/ArielSettingsProvider/src/com/android/providers/arielsettings/ArielSettingsProvider.java
deleted file mode 100644
index f0a3cb4..0000000
--- a/packages/ArielSettingsProvider/src/com/android/providers/arielsettings/ArielSettingsProvider.java
+++ /dev/null
@@ -1,1861 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.providers.arielsettings;
-
-import android.Manifest;
-import android.app.ActivityManager;
-import android.app.AppOpsManager;
-import android.app.backup.BackupManager;
-import android.content.BroadcastReceiver;
-import android.content.ContentProvider;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.UserInfo;
-import android.database.Cursor;
-import android.database.MatrixCursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteQueryBuilder;
-import android.hardware.camera2.utils.ArrayUtils;
-import android.media.AudioManager;
-import android.net.Uri;
-import android.os.Binder;
-import android.os.Build;
-import android.os.Bundle;
-import android.os.DropBoxManager;
-import android.os.Environment;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import android.os.ParcelFileDescriptor;
-import android.os.Process;
-import android.os.SystemProperties;
-import android.os.UserHandle;
-import android.os.UserManager;
-import android.provider.ArielSettings;
-import android.text.TextUtils;
-import android.util.ArrayMap;
-import android.util.ArraySet;
-import android.util.Slog;
-import android.util.SparseArray;
-
-import com.android.internal.annotations.GuardedBy;
-import com.android.internal.content.PackageMonitor;
-import com.android.internal.os.BackgroundThread;
-
-import java.io.File;
-import java.io.FileDescriptor;
-import java.io.FileNotFoundException;
-import java.io.PrintWriter;
-import java.security.SecureRandom;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.regex.Pattern;
-
-import com.android.providers.arielsettings.ArielSettingsState.Setting;
-
-/**
- * <p>
- * This class is a content provider that publishes the system settings.
- * It can be accessed via the content provider APIs or via custom call
- * commands. The latter is a bit faster and is the preferred way to access
- * the platform settings.
- * </p>
- * <p>
- * There are three settings types, global (with signature level protection
- * and shared across users), secure (with signature permission level
- * protection and per user), and system (with dangerous permission level
- * protection and per user). Global settings are stored under the device owner.
- * Each of these settings is represented by a {@link
- * com.android.providers.settings.SettingsState} object mapped to an integer
- * key derived from the setting type in the most significant bits and user
- * id in the least significant bits. Settings are synchronously loaded on
- * instantiation of a SettingsState and asynchronously persisted on mutation.
- * Settings are stored in the user specific system directory.
- * </p>
- * <p>
- * Apps targeting APIs Lollipop MR1 and lower can add custom settings entries
- * and get a warning. Targeting higher API version prohibits this as the
- * system settings are not a place for apps to save their state. When a package
- * is removed the settings it added are deleted. Apps cannot delete system
- * settings added by the platform. System settings values are validated to
- * ensure the clients do not put bad values. Global and secure settings are
- * changed only by trusted parties, therefore no validation is performed. Also
- * there is a limit on the amount of app specific settings that can be added
- * to prevent unlimited growth of the system process memory footprint.
- * </p>
- */
-@SuppressWarnings("deprecation")
-public class ArielSettingsProvider extends ContentProvider {
-    private static final boolean DEBUG = false;
-
-    private static final boolean DROP_DATABASE_ON_MIGRATION = !Build.IS_DEBUGGABLE;
-
-    private static final String LOG_TAG = "ArielSettingsProvider";
-
-    private static final String TABLE_SYSTEM = "system";
-    private static final String TABLE_SECURE = "secure";
-    private static final String TABLE_GLOBAL = "global";
-
-    // Old tables no longer exist.
-    private static final String TABLE_FAVORITES = "favorites";
-    private static final String TABLE_OLD_FAVORITES = "old_favorites";
-    private static final String TABLE_BLUETOOTH_DEVICES = "bluetooth_devices";
-    private static final String TABLE_BOOKMARKS = "bookmarks";
-    private static final String TABLE_ANDROID_METADATA = "android_metadata";
-
-    // The set of removed legacy tables.
-    private static final Set<String> REMOVED_LEGACY_TABLES = new ArraySet<>();
-    static {
-        REMOVED_LEGACY_TABLES.add(TABLE_FAVORITES);
-        REMOVED_LEGACY_TABLES.add(TABLE_OLD_FAVORITES);
-        REMOVED_LEGACY_TABLES.add(TABLE_BLUETOOTH_DEVICES);
-        REMOVED_LEGACY_TABLES.add(TABLE_BOOKMARKS);
-        REMOVED_LEGACY_TABLES.add(TABLE_ANDROID_METADATA);
-    }
-
-    private static final int MUTATION_OPERATION_INSERT = 1;
-    private static final int MUTATION_OPERATION_DELETE = 2;
-    private static final int MUTATION_OPERATION_UPDATE = 3;
-
-    private static final String[] ALL_COLUMNS = new String[] {
-            ArielSettings.NameValueTable._ID,
-            ArielSettings.NameValueTable.NAME,
-            ArielSettings.NameValueTable.VALUE
-    };
-
-    private static final Bundle NULL_SETTING = Bundle.forPair(ArielSettings.NameValueTable.VALUE, null);
-
-    // Per user settings that cannot be modified if associated user restrictions are enabled.
-//    private static final Map<String, String> sSettingToUserRestrictionMap = new ArrayMap<>();
-//    static {
-//        sSettingToUserRestrictionMap.put(Settings.Secure.LOCATION_MODE,
-//                UserManager.DISALLOW_SHARE_LOCATION);
-//        sSettingToUserRestrictionMap.put(Settings.Secure.LOCATION_PROVIDERS_ALLOWED,
-//                UserManager.DISALLOW_SHARE_LOCATION);
-//        sSettingToUserRestrictionMap.put(Settings.Secure.INSTALL_NON_MARKET_APPS,
-//                UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES);
-//        sSettingToUserRestrictionMap.put(Settings.Global.ADB_ENABLED,
-//                UserManager.DISALLOW_DEBUGGING_FEATURES);
-//        sSettingToUserRestrictionMap.put(Settings.Global.PACKAGE_VERIFIER_ENABLE,
-//                UserManager.ENSURE_VERIFY_APPS);
-//        sSettingToUserRestrictionMap.put(Settings.Global.PREFERRED_NETWORK_MODE,
-//                UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS);
-//    }
-
-    // Per user secure settings that moved to the for all users global settings.
-//    static final Set<String> sSecureMovedToGlobalSettings = new ArraySet<>();
-//    static {
-//        Settings.Secure.getMovedToGlobalSettings(sSecureMovedToGlobalSettings);
-//    }
-
-    // Per user system settings that moved to the for all users global settings.
-//    static final Set<String> sSystemMovedToGlobalSettings = new ArraySet<>();
-//    static {
-//        Settings.System.getMovedToGlobalSettings(sSystemMovedToGlobalSettings);
-//    }
-//
-//    // Per user system settings that moved to the per user secure settings.
-//    static final Set<String> sSystemMovedToSecureSettings = new ArraySet<>();
-//    static {
-//        Settings.System.getMovedToSecureSettings(sSystemMovedToSecureSettings);
-//    }
-//
-//    // Per all users global settings that moved to the per user secure settings.
-//    static final Set<String> sGlobalMovedToSecureSettings = new ArraySet<>();
-//    static {
-//        Settings.Global.getMovedToSecureSettings(sGlobalMovedToSecureSettings);
-//    }
-//
-    // Per user secure settings that are cloned for the managed profiles of the user.
-    private static final Set<String> sSecureCloneToManagedSettings = new ArraySet<>();
-//
-    // Per user system settings that are cloned for the managed profiles of the user.
-    private static final Set<String> sSystemCloneToManagedSettings = new ArraySet<>();
-
-    private final Object mLock = new Object();
-
-    @GuardedBy("mLock")
-    private SettingsRegistry mSettingsRegistry;
-
-    // We have to call in the user manager with no lock held,
-    private volatile UserManager mUserManager;
-
-    // We have to call in the package manager with no lock held,
-    private volatile PackageManager mPackageManager;
-
-    @Override
-    public boolean onCreate() {
-        synchronized (mLock) {
-            mUserManager = (UserManager) getContext().getSystemService(Context.USER_SERVICE);
-            mPackageManager = getContext().getPackageManager();
-            mSettingsRegistry = new SettingsRegistry();
-        }
-        registerBroadcastReceivers();
-        return true;
-    }
-
-    @Override
-    public Bundle call(String method, String name, Bundle args) {
-        final int requestingUserId = getRequestingUserId(args);
-        switch (method) {
-            case ArielSettings.CALL_METHOD_GET_GLOBAL: {
-                Setting setting = getGlobalSetting(name);
-                return packageValueForCallResult(setting);
-            }
-
-            case ArielSettings.CALL_METHOD_GET_SECURE: {
-                Setting setting = getSecureSetting(name, requestingUserId);
-                return packageValueForCallResult(setting);
-            }
-
-            case ArielSettings.CALL_METHOD_GET_SYSTEM: {
-                Setting setting = getSystemSetting(name, requestingUserId);
-                return packageValueForCallResult(setting);
-            }
-
-            case ArielSettings.CALL_METHOD_PUT_GLOBAL: {
-                String value = getSettingValue(args);
-                insertGlobalSetting(name, value, requestingUserId);
-                break;
-            }
-
-            case ArielSettings.CALL_METHOD_PUT_SECURE: {
-                String value = getSettingValue(args);
-                insertSecureSetting(name, value, requestingUserId);
-                break;
-            }
-
-            case ArielSettings.CALL_METHOD_PUT_SYSTEM: {
-                String value = getSettingValue(args);
-                insertSystemSetting(name, value, requestingUserId);
-                break;
-            }
-
-            default: {
-                Slog.w(LOG_TAG, "call() with invalid method: " + method);
-            } break;
-        }
-
-        return null;
-    }
-
-    @Override
-    public String getType(Uri uri) {
-        Arguments args = new Arguments(uri, null, null, true);
-        if (TextUtils.isEmpty(args.name)) {
-            return "vnd.android.cursor.dir/" + args.table;
-        } else {
-            return "vnd.android.cursor.item/" + args.table;
-        }
-    }
-
-    @Override
-    public Cursor query(Uri uri, String[] projection, String where, String[] whereArgs,
-            String order) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "query() for user: " + UserHandle.getCallingUserId());
-        }
-
-        Arguments args = new Arguments(uri, where, whereArgs, true);
-        String[] normalizedProjection = normalizeProjection(projection);
-
-        // If a legacy table that is gone, done.
-        if (REMOVED_LEGACY_TABLES.contains(args.table)) {
-            return new MatrixCursor(normalizedProjection, 0);
-        }
-
-        switch (args.table) {
-            case TABLE_GLOBAL: {
-                if (args.name != null) {
-                    Setting setting = getGlobalSetting(args.name);
-                    return packageSettingForQuery(setting, normalizedProjection);
-                } else {
-                    return getAllGlobalSettings(projection);
-                }
-            }
-
-            case TABLE_SECURE: {
-                final int userId = UserHandle.getCallingUserId();
-                if (args.name != null) {
-                    Setting setting = getSecureSetting(args.name, userId);
-                    return packageSettingForQuery(setting, normalizedProjection);
-                } else {
-                    return getAllSecureSettings(userId, projection);
-                }
-            }
-
-            case TABLE_SYSTEM: {
-                final int userId = UserHandle.getCallingUserId();
-                if (args.name != null) {
-                    Setting setting = getSystemSetting(args.name, userId);
-                    return packageSettingForQuery(setting, normalizedProjection);
-                } else {
-                    return getAllSystemSettings(userId, projection);
-                }
-            }
-
-            default: {
-                throw new IllegalArgumentException("Invalid Uri path:" + uri);
-            }
-        }
-    }
-
-    @Override
-    public Uri insert(Uri uri, ContentValues values) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "insert() for user: " + UserHandle.getCallingUserId());
-        }
-
-        String table = getValidTableOrThrow(uri);
-
-        // If a legacy table that is gone, done.
-        if (REMOVED_LEGACY_TABLES.contains(table)) {
-            return null;
-        }
-
-        String name = values.getAsString(ArielSettings.Secure.NAME);
-        if (!isKeyValid(name)) {
-            return null;
-        }
-
-        String value = values.getAsString(ArielSettings.Secure.VALUE);
-
-        switch (table) {
-            case TABLE_GLOBAL: {
-                if (insertGlobalSetting(name, value, UserHandle.getCallingUserId())) {
-                    return Uri.withAppendedPath(ArielSettings.Global.CONTENT_URI, name);
-                }
-            } break;
-
-            case TABLE_SECURE: {
-                if (insertSecureSetting(name, value, UserHandle.getCallingUserId())) {
-                    return Uri.withAppendedPath(ArielSettings.Secure.CONTENT_URI, name);
-                }
-            } break;
-
-            case TABLE_SYSTEM: {
-                if (insertSystemSetting(name, value, UserHandle.getCallingUserId())) {
-                    return Uri.withAppendedPath(ArielSettings.System.CONTENT_URI, name);
-                }
-            } break;
-
-            default: {
-                throw new IllegalArgumentException("Bad Uri path:" + uri);
-            }
-        }
-
-        return null;
-    }
-
-    @Override
-    public int bulkInsert(Uri uri, ContentValues[] allValues) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "bulkInsert() for user: " + UserHandle.getCallingUserId());
-        }
-
-        int insertionCount = 0;
-        final int valuesCount = allValues.length;
-        for (int i = 0; i < valuesCount; i++) {
-            ContentValues values = allValues[i];
-            if (insert(uri, values) != null) {
-                insertionCount++;
-            }
-        }
-
-        return insertionCount;
-    }
-
-    @Override
-    public int delete(Uri uri, String where, String[] whereArgs) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "delete() for user: " + UserHandle.getCallingUserId());
-        }
-
-        Arguments args = new Arguments(uri, where, whereArgs, false);
-
-        // If a legacy table that is gone, done.
-        if (REMOVED_LEGACY_TABLES.contains(args.table)) {
-            return 0;
-        }
-
-        if (!isKeyValid(args.name)) {
-            return 0;
-        }
-
-        switch (args.table) {
-            case TABLE_GLOBAL: {
-                final int userId = UserHandle.getCallingUserId();
-                return deleteGlobalSetting(args.name, userId) ? 1 : 0;
-            }
-
-            case TABLE_SECURE: {
-                final int userId = UserHandle.getCallingUserId();
-                return deleteSecureSetting(args.name, userId) ? 1 : 0;
-            }
-
-            case TABLE_SYSTEM: {
-                final int userId = UserHandle.getCallingUserId();
-                return deleteSystemSetting(args.name, userId) ? 1 : 0;
-            }
-
-            default: {
-                throw new IllegalArgumentException("Bad Uri path:" + uri);
-            }
-        }
-    }
-
-    @Override
-    public int update(Uri uri, ContentValues values, String where, String[] whereArgs) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "update() for user: " + UserHandle.getCallingUserId());
-        }
-
-        Arguments args = new Arguments(uri, where, whereArgs, false);
-
-        // If a legacy table that is gone, done.
-        if (REMOVED_LEGACY_TABLES.contains(args.table)) {
-            return 0;
-        }
-
-        String name = values.getAsString(ArielSettings.Secure.NAME);
-        if (!isKeyValid(name)) {
-            return 0;
-        }
-        String value = values.getAsString(ArielSettings.Secure.VALUE);
-
-        switch (args.table) {
-            case TABLE_GLOBAL: {
-                final int userId = UserHandle.getCallingUserId();
-                return updateGlobalSetting(args.name, value, userId) ? 1 : 0;
-            }
-
-            case TABLE_SECURE: {
-                final int userId = UserHandle.getCallingUserId();
-                return updateSecureSetting(args.name, value, userId) ? 1 : 0;
-            }
-
-            case TABLE_SYSTEM: {
-                final int userId = UserHandle.getCallingUserId();
-                return updateSystemSetting(args.name, value, userId) ? 1 : 0;
-            }
-
-            default: {
-                throw new IllegalArgumentException("Invalid Uri path:" + uri);
-            }
-        }
-    }
-
-    @Override
-    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
-        throw new FileNotFoundException("Direct file access no longer supported; "
-                + "ringtone playback is available through android.media.Ringtone");
-    }
-
-    @Override
-    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
-        synchronized (mLock) {
-            final long identity = Binder.clearCallingIdentity();
-            try {
-                List<UserInfo> users = mUserManager.getUsers(true);
-                final int userCount = users.size();
-                for (int i = 0; i < userCount; i++) {
-                    UserInfo user = users.get(i);
-                    dumpForUser(user.id, pw);
-                }
-            } finally {
-                Binder.restoreCallingIdentity(identity);
-            }
-        }
-    }
-
-    private void dumpForUser(int userId, PrintWriter pw) {
-        if (userId == UserHandle.USER_OWNER) {
-            pw.println("GLOBAL SETTINGS (user " + userId + ")");
-            Cursor globalCursor = getAllGlobalSettings(ALL_COLUMNS);
-            dumpSettings(globalCursor, pw);
-            pw.println();
-        }
-
-        pw.println("SECURE SETTINGS (user " + userId + ")");
-        Cursor secureCursor = getAllSecureSettings(userId, ALL_COLUMNS);
-        dumpSettings(secureCursor, pw);
-        pw.println();
-
-        pw.println("SYSTEM SETTINGS (user " + userId + ")");
-        Cursor systemCursor = getAllSystemSettings(userId, ALL_COLUMNS);
-        dumpSettings(systemCursor, pw);
-        pw.println();
-    }
-
-    private void dumpSettings(Cursor cursor, PrintWriter pw) {
-        if (cursor == null || !cursor.moveToFirst()) {
-            return;
-        }
-
-        final int idColumnIdx = cursor.getColumnIndex(ArielSettings.NameValueTable._ID);
-        final int nameColumnIdx = cursor.getColumnIndex(ArielSettings.NameValueTable.NAME);
-        final int valueColumnIdx = cursor.getColumnIndex(ArielSettings.NameValueTable.VALUE);
-
-        do {
-            pw.append("_id:").append(toDumpString(cursor.getString(idColumnIdx)));
-            pw.append(" name:").append(toDumpString(cursor.getString(nameColumnIdx)));
-            pw.append(" value:").append(toDumpString(cursor.getString(valueColumnIdx)));
-            pw.println();
-        } while (cursor.moveToNext());
-    }
-
-    private static String toDumpString(String s) {
-        if (s != null) {
-            return s;
-        }
-        return "{null}";
-    }
-
-    private void registerBroadcastReceivers() {
-        IntentFilter userFilter = new IntentFilter();
-        userFilter.addAction(Intent.ACTION_USER_REMOVED);
-        userFilter.addAction(Intent.ACTION_USER_STOPPED);
-
-        getContext().registerReceiver(new BroadcastReceiver() {
-            @Override
-            public void onReceive(Context context, Intent intent) {
-                final int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE,
-                        UserHandle.USER_OWNER);
-
-                switch (intent.getAction()) {
-                    case Intent.ACTION_USER_REMOVED: {
-                        mSettingsRegistry.removeUserStateLocked(userId, true);
-                    } break;
-
-                    case Intent.ACTION_USER_STOPPED: {
-                        mSettingsRegistry.removeUserStateLocked(userId, false);
-                    } break;
-                }
-            }
-        }, userFilter);
-
-        PackageMonitor monitor = new PackageMonitor() {
-            @Override
-            public void onPackageRemoved(String packageName, int uid) {
-                synchronized (mLock) {
-                    mSettingsRegistry.onPackageRemovedLocked(packageName,
-                            UserHandle.getUserId(uid));
-                }
-            }
-        };
-
-        // package changes
-        monitor.register(getContext(), BackgroundThread.getHandler().getLooper(),
-                UserHandle.ALL, true);
-    }
-
-    private Cursor getAllGlobalSettings(String[] projection) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "getAllGlobalSettings()");
-        }
-
-        synchronized (mLock) {
-            // Get the settings.
-            ArielSettingsState settingsState = mSettingsRegistry.getSettingsLocked(
-                    SettingsRegistry.SETTINGS_TYPE_GLOBAL, UserHandle.USER_OWNER);
-
-            List<String> names = settingsState.getSettingNamesLocked();
-
-            final int nameCount = names.size();
-
-            String[] normalizedProjection = normalizeProjection(projection);
-            MatrixCursor result = new MatrixCursor(normalizedProjection, nameCount);
-
-            // Anyone can get the global settings, so no security checks.
-            for (int i = 0; i < nameCount; i++) {
-                String name = names.get(i);
-                Setting setting = settingsState.getSettingLocked(name);
-                appendSettingToCursor(result, setting);
-            }
-
-            return result;
-        }
-    }
-
-    private Setting getGlobalSetting(String name) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "getGlobalSetting(" + name + ")");
-        }
-
-        // Get the value.
-        synchronized (mLock) {
-            return mSettingsRegistry.getSettingLocked(SettingsRegistry.SETTINGS_TYPE_GLOBAL,
-                    UserHandle.USER_OWNER, name);
-        }
-    }
-
-    private boolean updateGlobalSetting(String name, String value, int requestingUserId) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "updateGlobalSetting(" + name + ", " + value + ")");
-        }
-        return mutateGlobalSetting(name, value, requestingUserId, MUTATION_OPERATION_UPDATE);
-    }
-
-    private boolean insertGlobalSetting(String name, String value, int requestingUserId) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "insertGlobalSetting(" + name + ", " + value + ")");
-        }
-        return mutateGlobalSetting(name, value, requestingUserId, MUTATION_OPERATION_INSERT);
-    }
-
-    private boolean deleteGlobalSetting(String name, int requestingUserId) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "deleteGlobalSettingLocked(" + name + ")");
-        }
-        return mutateGlobalSetting(name, null, requestingUserId, MUTATION_OPERATION_DELETE);
-    }
-
-    private boolean mutateGlobalSetting(String name, String value, int requestingUserId,
-            int operation) {
-        // Make sure the caller can change the settings - treated as secure.
-        enforceWritePermission(Manifest.permission.WRITE_ARIEL_SECURE_SETTINGS);
-
-        // Resolve the userId on whose behalf the call is made.
-        final int callingUserId = resolveCallingUserIdEnforcingPermissionsLocked(requestingUserId);
-
-        // If this is a setting that is currently restricted for this user, done.
-        if (isGlobalOrSecureSettingRestrictedForUser(name, callingUserId)) {
-            return false;
-        }
-
-        // Perform the mutation.
-        synchronized (mLock) {
-            switch (operation) {
-                case MUTATION_OPERATION_INSERT: {
-                    return mSettingsRegistry
-                            .insertSettingLocked(SettingsRegistry.SETTINGS_TYPE_GLOBAL,
-                                    UserHandle.USER_OWNER, name, value, getCallingPackage());
-                }
-
-                case MUTATION_OPERATION_DELETE: {
-                    return mSettingsRegistry.deleteSettingLocked(
-                            SettingsRegistry.SETTINGS_TYPE_GLOBAL,
-                            UserHandle.USER_OWNER, name);
-                }
-
-                case MUTATION_OPERATION_UPDATE: {
-                    return mSettingsRegistry
-                            .updateSettingLocked(SettingsRegistry.SETTINGS_TYPE_GLOBAL,
-                                    UserHandle.USER_OWNER, name, value, getCallingPackage());
-                }
-            }
-        }
-
-        return false;
-    }
-
-    private Cursor getAllSecureSettings(int userId, String[] projection) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "getAllSecureSettings(" + userId + ")");
-        }
-
-        // Resolve the userId on whose behalf the call is made.
-        final int callingUserId = resolveCallingUserIdEnforcingPermissionsLocked(userId);
-
-        synchronized (mLock) {
-            List<String> names = mSettingsRegistry.getSettingsNamesLocked(
-                    SettingsRegistry.SETTINGS_TYPE_SECURE, callingUserId);
-
-            final int nameCount = names.size();
-
-            String[] normalizedProjection = normalizeProjection(projection);
-            MatrixCursor result = new MatrixCursor(normalizedProjection, nameCount);
-
-            for (int i = 0; i < nameCount; i++) {
-                String name = names.get(i);
-                // Determine the owning user as some profile settings are cloned from the parent.
-                final int owningUserId = resolveOwningUserIdForSecureSettingLocked(callingUserId,
-                        name);
-
-                // Special case for location (sigh).
-                if (isLocationProvidersAllowedRestricted(name, callingUserId, owningUserId)) {
-                    return null;
-                }
-
-                Setting setting = mSettingsRegistry.getSettingLocked(
-                        SettingsRegistry.SETTINGS_TYPE_SECURE, owningUserId, name);
-                appendSettingToCursor(result, setting);
-            }
-
-            return result;
-        }
-    }
-
-    private Setting getSecureSetting(String name, int requestingUserId) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "getSecureSetting(" + name + ", " + requestingUserId + ")");
-        }
-
-        // Make sure the caller can change the settings - treated as secure.
-        enforceWritePermission(Manifest.permission.WRITE_ARIEL_SECURE_SETTINGS);
-
-        // Resolve the userId on whose behalf the call is made.
-        final int callingUserId = resolveCallingUserIdEnforcingPermissionsLocked(requestingUserId);
-
-        // Determine the owning user as some profile settings are cloned from the parent.
-        final int owningUserId = resolveOwningUserIdForSecureSettingLocked(callingUserId, name);
-
-        // Special case for location (sigh).
-        if (isLocationProvidersAllowedRestricted(name, callingUserId, owningUserId)) {
-            return null;
-        }
-
-        // Get the value.
-        synchronized (mLock) {
-            return mSettingsRegistry.getSettingLocked(SettingsRegistry.SETTINGS_TYPE_SECURE,
-                    owningUserId, name);
-        }
-    }
-
-    private boolean insertSecureSetting(String name, String value, int requestingUserId) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "insertSecureSetting(" + name + ", " + value + ", "
-                    + requestingUserId + ")");
-        }
-
-        return mutateSecureSetting(name, value, requestingUserId, MUTATION_OPERATION_INSERT);
-    }
-
-    private boolean deleteSecureSetting(String name, int requestingUserId) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "deleteSecureSetting(" + name + ", " + requestingUserId + ")");
-        }
-
-        return mutateSecureSetting(name, null, requestingUserId, MUTATION_OPERATION_DELETE);
-    }
-
-    private boolean updateSecureSetting(String name, String value, int requestingUserId) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "updateSecureSetting(" + name + ", " + value + ", "
-                    + requestingUserId + ")");
-        }
-
-        return mutateSecureSetting(name, value, requestingUserId, MUTATION_OPERATION_UPDATE);
-    }
-
-    private boolean mutateSecureSetting(String name, String value, int requestingUserId,
-            int operation) {
-        // Make sure the caller can change the settings.
-        enforceWritePermission(Manifest.permission.WRITE_ARIEL_SECURE_SETTINGS);
-
-        // Resolve the userId on whose behalf the call is made.
-        final int callingUserId = resolveCallingUserIdEnforcingPermissionsLocked(requestingUserId);
-
-        // If this is a setting that is currently restricted for this user, done.
-        if (isGlobalOrSecureSettingRestrictedForUser(name, callingUserId)) {
-            return false;
-        }
-
-        // Determine the owning user as some profile settings are cloned from the parent.
-        final int owningUserId = resolveOwningUserIdForSecureSettingLocked(callingUserId, name);
-
-        // Only the owning user can change the setting.
-        if (owningUserId != callingUserId) {
-            return false;
-        }
-
-        // Mutate the value.
-        synchronized (mLock) {
-            switch (operation) {
-                case MUTATION_OPERATION_INSERT: {
-                    return mSettingsRegistry
-                            .insertSettingLocked(SettingsRegistry.SETTINGS_TYPE_SECURE,
-                                    owningUserId, name, value, getCallingPackage());
-                }
-
-                case MUTATION_OPERATION_DELETE: {
-                    return mSettingsRegistry.deleteSettingLocked(
-                            SettingsRegistry.SETTINGS_TYPE_SECURE,
-                            owningUserId, name);
-                }
-
-                case MUTATION_OPERATION_UPDATE: {
-                    return mSettingsRegistry
-                            .updateSettingLocked(SettingsRegistry.SETTINGS_TYPE_SECURE,
-                                    owningUserId, name, value, getCallingPackage());
-                }
-            }
-        }
-
-        return false;
-    }
-
-    private Cursor getAllSystemSettings(int userId, String[] projection) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "getAllSecureSystem(" + userId + ")");
-        }
-
-        // Resolve the userId on whose behalf the call is made.
-        final int callingUserId = resolveCallingUserIdEnforcingPermissionsLocked(userId);
-
-        synchronized (mLock) {
-            List<String> names = mSettingsRegistry.getSettingsNamesLocked(
-                    SettingsRegistry.SETTINGS_TYPE_SYSTEM, callingUserId);
-
-            final int nameCount = names.size();
-
-            String[] normalizedProjection = normalizeProjection(projection);
-            MatrixCursor result = new MatrixCursor(normalizedProjection, nameCount);
-
-            for (int i = 0; i < nameCount; i++) {
-                String name = names.get(i);
-
-                // Determine the owning user as some profile settings are cloned from the parent.
-                final int owningUserId = resolveOwningUserIdForSystemSettingLocked(callingUserId,
-                        name);
-
-                Setting setting = mSettingsRegistry.getSettingLocked(
-                        SettingsRegistry.SETTINGS_TYPE_SYSTEM, owningUserId, name);
-                appendSettingToCursor(result, setting);
-            }
-
-            return result;
-        }
-    }
-
-    private Setting getSystemSetting(String name, int requestingUserId) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "getSystemSetting(" + name + ", " + requestingUserId + ")");
-        }
-
-        // Resolve the userId on whose behalf the call is made.
-        final int callingUserId = resolveCallingUserIdEnforcingPermissionsLocked(requestingUserId);
-
-        // Determine the owning user as some profile settings are cloned from the parent.
-        final int owningUserId = resolveOwningUserIdForSystemSettingLocked(callingUserId, name);
-
-        // Get the value.
-        synchronized (mLock) {
-            return mSettingsRegistry.getSettingLocked(SettingsRegistry.SETTINGS_TYPE_SYSTEM,
-                    owningUserId, name);
-        }
-    }
-
-    private boolean insertSystemSetting(String name, String value, int requestingUserId) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "insertSystemSetting(" + name + ", " + value + ", "
-                    + requestingUserId + ")");
-        }
-
-        return mutateSystemSetting(name, value, requestingUserId, MUTATION_OPERATION_INSERT);
-    }
-
-    private boolean deleteSystemSetting(String name, int requestingUserId) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "deleteSystemSetting(" + name + ", " + requestingUserId + ")");
-        }
-
-        return mutateSystemSetting(name, null, requestingUserId, MUTATION_OPERATION_DELETE);
-    }
-
-    private boolean updateSystemSetting(String name, String value, int requestingUserId) {
-        if (DEBUG) {
-            Slog.v(LOG_TAG, "updateSystemSetting(" + name + ", " + value + ", "
-                    + requestingUserId + ")");
-        }
-
-        return mutateSystemSetting(name, value, requestingUserId, MUTATION_OPERATION_UPDATE);
-    }
-
-    private boolean mutateSystemSetting(String name, String value, int runAsUserId,
-            int operation) {
-        if (!hasWriteSecureSettingsPermission()) {
-            // If the caller doesn't hold WRITE_ARIEL_SECURE_SETTINGS, we verify whether this
-            // operation is allowed for the calling package through appops.
-            if (!ArielSettings.checkAndNoteWriteSettingsOperation(getContext(),
-                    Binder.getCallingUid(), getCallingPackage(), true)) {
-                return false;
-            }
-        }
-
-        // Enforce what the calling package can mutate the system settings.
-        enforceRestrictedSystemSettingsMutationForCallingPackage(operation, name);
-
-        // Resolve the userId on whose behalf the call is made.
-        final int callingUserId = resolveCallingUserIdEnforcingPermissionsLocked(runAsUserId);
-
-        // Determine the owning user as some profile settings are cloned from the parent.
-        final int owningUserId = resolveOwningUserIdForSystemSettingLocked(callingUserId, name);
-
-        // Only the owning user id can change the setting.
-        if (owningUserId != callingUserId) {
-            return false;
-        }
-
-        // Mutate the value.
-        synchronized (mLock) {
-            switch (operation) {
-                case MUTATION_OPERATION_INSERT: {
-                    validateSystemSettingValue(name, value);
-                    return mSettingsRegistry
-                            .insertSettingLocked(SettingsRegistry.SETTINGS_TYPE_SYSTEM,
-                                    owningUserId, name, value, getCallingPackage());
-                }
-
-                case MUTATION_OPERATION_DELETE: {
-                    return mSettingsRegistry.deleteSettingLocked(
-                            SettingsRegistry.SETTINGS_TYPE_SYSTEM,
-                            owningUserId, name);
-                }
-
-                case MUTATION_OPERATION_UPDATE: {
-                    validateSystemSettingValue(name, value);
-                    return mSettingsRegistry
-                            .updateSettingLocked(SettingsRegistry.SETTINGS_TYPE_SYSTEM,
-                                    owningUserId, name, value, getCallingPackage());
-                }
-            }
-
-            return false;
-        }
-    }
-
-    private boolean hasWriteSecureSettingsPermission() {
-        // Write secure settings is a more protected permission. If caller has it we are good.
-        if (getContext().checkCallingOrSelfPermission(Manifest.permission.WRITE_ARIEL_SECURE_SETTINGS)
-                == PackageManager.PERMISSION_GRANTED) {
-            return true;
-        }
-
-        return false;
-    }
-
-    private void validateSystemSettingValue(String name, String value) {
-        ArielSettings.System.Validator validator = ArielSettings.System.VALIDATORS.get(name);
-        if (validator != null && !validator.validate(value)) {
-            throw new IllegalArgumentException("Invalid value: " + value
-                    + " for setting: " + name);
-        }
-    }
-
-    private boolean isLocationProvidersAllowedRestricted(String name, int callingUserId,
-            int owningUserId) {
-        // Optimization - location providers are restricted only for managed profiles.
-        if (callingUserId == owningUserId) {
-            return false;
-        }
-        return false;
-    }
-
-    private boolean isGlobalOrSecureSettingRestrictedForUser(String setting, int userId) {
-        return false;
-        //return mUserManager.hasUserRestriction(restriction, new UserHandle(userId));
-    }
-
-    private int resolveOwningUserIdForSecureSettingLocked(int userId, String setting) {
-        return resolveOwningUserIdLocked(userId, sSecureCloneToManagedSettings, setting);
-    }
-
-    private int resolveOwningUserIdForSystemSettingLocked(int userId, String setting) {
-        return resolveOwningUserIdLocked(userId, sSystemCloneToManagedSettings, setting);
-    }
-
-    private int resolveOwningUserIdLocked(int userId, Set<String> keys, String name) {
-        final int parentId = getGroupParentLocked(userId);
-        if (parentId != userId && keys.contains(name)) {
-            return parentId;
-        }
-        return userId;
-    }
-
-    private void enforceRestrictedSystemSettingsMutationForCallingPackage(int operation,
-            String name) {
-        // System/root/shell can mutate whatever secure settings they want.
-        final int callingUid = Binder.getCallingUid();
-        if (callingUid == android.os.Process.SYSTEM_UID
-                || callingUid == Process.SHELL_UID
-                || callingUid == Process.ROOT_UID) {
-            return;
-        }
-
-        switch (operation) {
-            case MUTATION_OPERATION_INSERT:
-                // Insert updates.
-            case MUTATION_OPERATION_UPDATE: {
-                if (ArielSettings.System.PUBLIC_SETTINGS.contains(name)) {
-                    return;
-                }
-
-                // The calling package is already verified.
-                PackageInfo packageInfo = getCallingPackageInfoOrThrow();
-
-                // Privileged apps can do whatever they want.
-                if ((packageInfo.applicationInfo.privateFlags
-                        & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {
-                    return;
-                }
-
-                warnOrThrowForUndesiredSecureSettingsMutationForTargetSdk(
-                        packageInfo.applicationInfo.targetSdkVersion, name);
-            } break;
-
-            case MUTATION_OPERATION_DELETE: {
-                if (ArielSettings.System.PUBLIC_SETTINGS.contains(name)
-                        || ArielSettings.System.PRIVATE_SETTINGS.contains(name)) {
-                    throw new IllegalArgumentException("You cannot delete system defined"
-                            + " secure settings.");
-                }
-
-                // The calling package is already verified.
-                PackageInfo packageInfo = getCallingPackageInfoOrThrow();
-
-                // Privileged apps can do whatever they want.
-                if ((packageInfo.applicationInfo.privateFlags &
-                        ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {
-                    return;
-                }
-
-                warnOrThrowForUndesiredSecureSettingsMutationForTargetSdk(
-                        packageInfo.applicationInfo.targetSdkVersion, name);
-            } break;
-        }
-    }
-
-    private PackageInfo getCallingPackageInfoOrThrow() {
-        try {
-            return mPackageManager.getPackageInfo(getCallingPackage(), 0);
-        } catch (PackageManager.NameNotFoundException e) {
-            throw new IllegalStateException("Calling package doesn't exist");
-        }
-    }
-
-    private int getGroupParentLocked(int userId) {
-        // Most frequent use case.
-        if (userId == UserHandle.USER_OWNER) {
-            return userId;
-        }
-        // We are in the same process with the user manager and the returned
-        // user info is a cached instance, so just look up instead of cache.
-        final long identity = Binder.clearCallingIdentity();
-        try {
-            // Just a lookup and not reentrant, so holding a lock is fine.
-            UserInfo userInfo = mUserManager.getProfileParent(userId);
-            return (userInfo != null) ? userInfo.id : userId;
-        } finally {
-            Binder.restoreCallingIdentity(identity);
-        }
-    }
-
-    private void enforceWritePermission(String permission) {
-        Slog.v(LOG_TAG,"Checking for permission on secure settings: "+permission);
-        if (getContext().checkCallingOrSelfPermission(permission)
-                != PackageManager.PERMISSION_GRANTED) {
-            throw new SecurityException("Permission denial: writing to settings requires:"
-                    + permission);
-        }
-    }
-
-    private static void warnOrThrowForUndesiredSecureSettingsMutationForTargetSdk(
-            int targetSdkVersion, String name) {
-        // If the app targets Lollipop MR1 or older SDK we warn, otherwise crash.
-        if (targetSdkVersion <= Build.VERSION_CODES.LOLLIPOP_MR1) {
-            if (ArielSettings.System.PRIVATE_SETTINGS.contains(name)) {
-                Slog.w(LOG_TAG, "You shouldn't not change private system settings."
-                        + " This will soon become an error.");
-            } else {
-                Slog.w(LOG_TAG, "You shouldn't keep your settings in the secure settings."
-                        + " This will soon become an error.");
-            }
-        } else {
-            if (ArielSettings.System.PRIVATE_SETTINGS.contains(name)) {
-                throw new IllegalArgumentException("You cannot change private secure settings.");
-            } else {
-                throw new IllegalArgumentException("You cannot keep your settings in"
-                        + " the secure settings.");
-            }
-        }
-    }
-
-    private static int resolveCallingUserIdEnforcingPermissionsLocked(int requestingUserId) {
-        if (requestingUserId == UserHandle.getCallingUserId()) {
-            return requestingUserId;
-        }
-        return ActivityManager.handleIncomingUser(Binder.getCallingPid(),
-                Binder.getCallingUid(), requestingUserId, false, true,
-                "get/set setting for user", null);
-    }
-
-    private static Bundle packageValueForCallResult(Setting setting) {
-        if (setting == null) {
-            return NULL_SETTING;
-        }
-        return Bundle.forPair(ArielSettings.NameValueTable.VALUE, setting.getValue());
-    }
-
-    private static int getRequestingUserId(Bundle args) {
-        final int callingUserId = UserHandle.getCallingUserId();
-        return (args != null) ? args.getInt(ArielSettings.CALL_METHOD_USER_KEY, callingUserId)
-                : callingUserId;
-    }
-
-    private static String getSettingValue(Bundle args) {
-        return (args != null) ? args.getString(ArielSettings.NameValueTable.VALUE) : null;
-    }
-
-    private static String getValidTableOrThrow(Uri uri) {
-        if (uri.getPathSegments().size() > 0) {
-            String table = uri.getPathSegments().get(0);
-            if (DatabaseHelper.isValidTable(table)) {
-                return table;
-            }
-            throw new IllegalArgumentException("Bad root path: " + table);
-        }
-        throw new IllegalArgumentException("Invalid URI:" + uri);
-    }
-
-    private static MatrixCursor packageSettingForQuery(Setting setting, String[] projection) {
-        if (setting == null) {
-            return new MatrixCursor(projection, 0);
-        }
-        MatrixCursor cursor = new MatrixCursor(projection, 1);
-        appendSettingToCursor(cursor, setting);
-        return cursor;
-    }
-
-    private static String[] normalizeProjection(String[] projection) {
-        if (projection == null) {
-            return ALL_COLUMNS;
-        }
-
-        final int columnCount = projection.length;
-        for (int i = 0; i < columnCount; i++) {
-            String column = projection[i];
-            if (!ArrayUtils.contains(ALL_COLUMNS, column)) {
-                throw new IllegalArgumentException("Invalid column: " + column);
-            }
-        }
-
-        return projection;
-    }
-
-    private static void appendSettingToCursor(MatrixCursor cursor, Setting setting) {
-        final int columnCount = cursor.getColumnCount();
-
-        String[] values =  new String[columnCount];
-
-        for (int i = 0; i < columnCount; i++) {
-            String column = cursor.getColumnName(i);
-
-            switch (column) {
-                case ArielSettings.NameValueTable._ID: {
-                    values[i] = setting.getId();
-                } break;
-
-                case ArielSettings.NameValueTable.NAME: {
-                    values[i] = setting.getName();
-                } break;
-
-                case ArielSettings.NameValueTable.VALUE: {
-                    values[i] = setting.getValue();
-                } break;
-            }
-        }
-
-        cursor.addRow(values);
-    }
-
-    private static boolean isKeyValid(String key) {
-        return !(TextUtils.isEmpty(key) || ArielSettingsState.isBinary(key));
-    }
-
-    private static final class Arguments {
-        private static final Pattern WHERE_PATTERN_WITH_PARAM_NO_BRACKETS =
-                Pattern.compile("[\\s]*name[\\s]*=[\\s]*\\?[\\s]*");
-
-        private static final Pattern WHERE_PATTERN_WITH_PARAM_IN_BRACKETS =
-                Pattern.compile("[\\s]*\\([\\s]*name[\\s]*=[\\s]*\\?[\\s]*\\)[\\s]*");
-
-        private static final Pattern WHERE_PATTERN_NO_PARAM_IN_BRACKETS =
-                Pattern.compile("[\\s]*\\([\\s]*name[\\s]*=[\\s]*['\"].*['\"][\\s]*\\)[\\s]*");
-
-        private static final Pattern WHERE_PATTERN_NO_PARAM_NO_BRACKETS =
-                Pattern.compile("[\\s]*name[\\s]*=[\\s]*['\"].*['\"][\\s]*");
-
-        public final String table;
-        public final String name;
-
-        public Arguments(Uri uri, String where, String[] whereArgs, boolean supportAll) {
-            final int segmentSize = uri.getPathSegments().size();
-            switch (segmentSize) {
-                case 1: {
-                    if (where != null
-                            && (WHERE_PATTERN_WITH_PARAM_NO_BRACKETS.matcher(where).matches()
-                                || WHERE_PATTERN_WITH_PARAM_IN_BRACKETS.matcher(where).matches())
-                            && whereArgs.length == 1) {
-                        name = whereArgs[0];
-                        table = computeTableForSetting(uri, name);
-                        return;
-                    } else if (where != null
-                            && (WHERE_PATTERN_NO_PARAM_NO_BRACKETS.matcher(where).matches()
-                                || WHERE_PATTERN_NO_PARAM_IN_BRACKETS.matcher(where).matches())) {
-                        final int startIndex = Math.max(where.indexOf("'"),
-                                where.indexOf("\"")) + 1;
-                        final int endIndex = Math.max(where.lastIndexOf("'"),
-                                where.lastIndexOf("\""));
-                        name = where.substring(startIndex, endIndex);
-                        table = computeTableForSetting(uri, name);
-                        return;
-                    } else if (supportAll && where == null && whereArgs == null) {
-                        name = null;
-                        table = computeTableForSetting(uri, null);
-                        return;
-                    }
-                } break;
-
-                case 2: {
-                    if (where == null && whereArgs == null) {
-                        name = uri.getPathSegments().get(1);
-                        table = computeTableForSetting(uri, name);
-                        return;
-                    }
-                } break;
-            }
-
-            EventLogTags.writeUnsupportedSettingsQuery(
-                    uri.toSafeString(), where, Arrays.toString(whereArgs));
-            String message = String.format( "Supported SQL:\n"
-                    + "  uri content://some_table/some_property with null where and where args\n"
-                    + "  uri content://some_table with query name=? and single name as arg\n"
-                    + "  uri content://some_table with query name=some_name and null args\n"
-                    + "  but got - uri:%1s, where:%2s whereArgs:%3s", uri, where,
-                    Arrays.toString(whereArgs));
-            throw new IllegalArgumentException(message);
-        }
-
-        private static String computeTableForSetting(Uri uri, String name) {
-            String table = getValidTableOrThrow(uri);
-
-//            if (name != null) {
-//                if (sSystemMovedToSecureSettings.contains(name)) {
-//                    table = TABLE_SECURE;
-//                }
-//
-//                if (sSystemMovedToGlobalSettings.contains(name)) {
-//                    table = TABLE_GLOBAL;
-//                }
-//
-//                if (sSecureMovedToGlobalSettings.contains(name)) {
-//                    table = TABLE_GLOBAL;
-//                }
-//
-//                if (sGlobalMovedToSecureSettings.contains(name)) {
-//                    table = TABLE_SECURE;
-//                }
-//            }
-
-            return table;
-        }
-    }
-
-    final class SettingsRegistry {
-        private static final String DROPBOX_TAG_USERLOG = "restricted_profile_ssaid";
-
-        private static final int SETTINGS_TYPE_GLOBAL = 0;
-        private static final int SETTINGS_TYPE_SYSTEM = 1;
-        private static final int SETTINGS_TYPE_SECURE = 2;
-
-        private static final int SETTINGS_TYPE_MASK = 0xF0000000;
-        private static final int SETTINGS_TYPE_SHIFT = 28;
-
-        private static final String SETTINGS_FILE_GLOBAL = "arielsettings_global.xml";
-        private static final String SETTINGS_FILE_SYSTEM = "arielsettings_system.xml";
-        private static final String SETTINGS_FILE_SECURE = "arielsettings_secure.xml";
-
-        private final SparseArray<ArielSettingsState> mSettingsStates = new SparseArray<>();
-
-        private final BackupManager mBackupManager;
-
-        private final Handler mHandler;
-
-        public SettingsRegistry() {
-            mBackupManager = new BackupManager(getContext());
-            mHandler = new MyHandler(getContext().getMainLooper());
-            migrateAllLegacySettingsIfNeeded();
-        }
-
-        public List<String> getSettingsNamesLocked(int type, int userId) {
-            final int key = makeKey(type, userId);
-            ArielSettingsState settingsState = peekSettingsStateLocked(key);
-            return settingsState.getSettingNamesLocked();
-        }
-
-        public ArielSettingsState getSettingsLocked(int type, int userId) {
-            final int key = makeKey(type, userId);
-            return peekSettingsStateLocked(key);
-        }
-
-        public void ensureSettingsForUserLocked(int userId) {
-            // Migrate the setting for this user if needed.
-            migrateLegacySettingsForUserIfNeededLocked(userId);
-
-            // Ensure global settings loaded if owner.
-            if (userId == UserHandle.USER_OWNER) {
-                final int globalKey = makeKey(SETTINGS_TYPE_GLOBAL, UserHandle.USER_OWNER);
-                ensureSettingsStateLocked(globalKey);
-            }
-
-            // Ensure secure settings loaded.
-            final int secureKey = makeKey(SETTINGS_TYPE_SECURE, userId);
-            ensureSettingsStateLocked(secureKey);
-
-            // Make sure the secure settings have an Android id set.
-            ArielSettingsState secureSettings = getSettingsLocked(SETTINGS_TYPE_SECURE, userId);
-            ensureSecureSettingAndroidIdSetLocked(secureSettings);
-
-            // Ensure system settings loaded.
-            final int systemKey = makeKey(SETTINGS_TYPE_SYSTEM, userId);
-            ensureSettingsStateLocked(systemKey);
-
-            // Upgrade the settings to the latest version.
-            UpgradeController upgrader = new UpgradeController(userId);
-            upgrader.upgradeIfNeededLocked();
-        }
-
-        private void ensureSettingsStateLocked(int key) {
-            if (mSettingsStates.get(key) == null) {
-                final int maxBytesPerPackage = getMaxBytesPerPackageForType(getTypeFromKey(key));
-                ArielSettingsState settingsState = new ArielSettingsState(mLock, getSettingsFile(key), key,
-                        maxBytesPerPackage);
-                mSettingsStates.put(key, settingsState);
-            }
-        }
-
-        public void removeUserStateLocked(int userId, boolean permanently) {
-            // We always keep the global settings in memory.
-
-            // Nuke system settings.
-            final int systemKey = makeKey(SETTINGS_TYPE_SYSTEM, userId);
-            final ArielSettingsState systemSettingsState = mSettingsStates.get(systemKey);
-            if (systemSettingsState != null) {
-                if (permanently) {
-                    mSettingsStates.remove(systemKey);
-                    systemSettingsState.destroyLocked(null);
-                } else {
-                    systemSettingsState.destroyLocked(new Runnable() {
-                        @Override
-                        public void run() {
-                            mSettingsStates.remove(systemKey);
-                        }
-                    });
-                }
-            }
-
-            // Nuke secure settings.
-            final int secureKey = makeKey(SETTINGS_TYPE_SECURE, userId);
-            final ArielSettingsState secureSettingsState = mSettingsStates.get(secureKey);
-            if (secureSettingsState != null) {
-                if (permanently) {
-                    mSettingsStates.remove(secureKey);
-                    secureSettingsState.destroyLocked(null);
-                } else {
-                    secureSettingsState.destroyLocked(new Runnable() {
-                        @Override
-                        public void run() {
-                            mSettingsStates.remove(secureKey);
-                        }
-                    });
-                }
-            }
-        }
-
-        public boolean insertSettingLocked(int type, int userId, String name, String value,
-                String packageName) {
-            final int key = makeKey(type, userId);
-
-            ArielSettingsState settingsState = peekSettingsStateLocked(key);
-            final boolean success = settingsState.insertSettingLocked(name, value, packageName);
-
-            if (success) {
-                notifyForSettingsChange(key, name);
-            }
-            return success;
-        }
-
-        public boolean deleteSettingLocked(int type, int userId, String name) {
-            final int key = makeKey(type, userId);
-
-            ArielSettingsState settingsState = peekSettingsStateLocked(key);
-            final boolean success = settingsState.deleteSettingLocked(name);
-
-            if (success) {
-                notifyForSettingsChange(key, name);
-            }
-            return success;
-        }
-
-        public Setting getSettingLocked(int type, int userId, String name) {
-            final int key = makeKey(type, userId);
-
-            ArielSettingsState settingsState = peekSettingsStateLocked(key);
-            return settingsState.getSettingLocked(name);
-        }
-
-        public boolean updateSettingLocked(int type, int userId, String name, String value,
-                String packageName) {
-            final int key = makeKey(type, userId);
-
-            ArielSettingsState settingsState = peekSettingsStateLocked(key);
-            final boolean success = settingsState.updateSettingLocked(name, value, packageName);
-
-            if (success) {
-                notifyForSettingsChange(key, name);
-            }
-
-            return success;
-        }
-
-        public void onPackageRemovedLocked(String packageName, int userId) {
-            // Global and secure settings are signature protected. Apps signed
-            // by the platform certificate are generally not uninstalled  and
-            // the main exception is tests. We trust components signed
-            // by the platform certificate and do not do a clean up after them.
-
-            final int systemKey = makeKey(SETTINGS_TYPE_SYSTEM, userId);
-            ArielSettingsState systemSettings = mSettingsStates.get(systemKey);
-            if (systemSettings != null) {
-                systemSettings.onPackageRemovedLocked(packageName);
-            }
-        }
-
-        private ArielSettingsState peekSettingsStateLocked(int key) {
-            ArielSettingsState settingsState = mSettingsStates.get(key);
-            if (settingsState != null) {
-                return settingsState;
-            }
-
-            ensureSettingsForUserLocked(getUserIdFromKey(key));
-            return mSettingsStates.get(key);
-        }
-
-        private void migrateAllLegacySettingsIfNeeded() {
-            synchronized (mLock) {
-                final int key = makeKey(SETTINGS_TYPE_GLOBAL, UserHandle.USER_OWNER);
-                File globalFile = getSettingsFile(key);
-                if (globalFile.exists()) {
-                    return;
-                }
-
-                final long identity = Binder.clearCallingIdentity();
-                try {
-                    List<UserInfo> users = mUserManager.getUsers(true);
-
-                    final int userCount = users.size();
-                    for (int i = 0; i < userCount; i++) {
-                        final int userId = users.get(i).id;
-
-                        DatabaseHelper dbHelper = new DatabaseHelper(getContext(), userId);
-                        SQLiteDatabase database = dbHelper.getWritableDatabase();
-                        migrateLegacySettingsForUserLocked(dbHelper, database, userId);
-
-                        // Upgrade to the latest version.
-                        UpgradeController upgrader = new UpgradeController(userId);
-                        upgrader.upgradeIfNeededLocked();
-
-                        // Drop from memory if not a running user.
-                        if (!mUserManager.isUserRunning(new UserHandle(userId))) {
-                            removeUserStateLocked(userId, false);
-                        }
-                    }
-                } finally {
-                    Binder.restoreCallingIdentity(identity);
-                }
-            }
-        }
-
-        private void migrateLegacySettingsForUserIfNeededLocked(int userId) {
-            // Every user has secure settings and if no file we need to migrate.
-            final int secureKey = makeKey(SETTINGS_TYPE_SECURE, userId);
-            File secureFile = getSettingsFile(secureKey);
-            if (secureFile.exists()) {
-                return;
-            }
-
-            DatabaseHelper dbHelper = new DatabaseHelper(getContext(), userId);
-            SQLiteDatabase database = dbHelper.getWritableDatabase();
-
-            migrateLegacySettingsForUserLocked(dbHelper, database, userId);
-        }
-
-        private void migrateLegacySettingsForUserLocked(DatabaseHelper dbHelper,
-                SQLiteDatabase database, int userId) {
-            // Move over the global settings if owner.
-            if (userId == UserHandle.USER_OWNER) {
-                final int globalKey = makeKey(SETTINGS_TYPE_GLOBAL, userId);
-                ensureSettingsStateLocked(globalKey);
-                ArielSettingsState globalSettings = mSettingsStates.get(globalKey);
-                migrateLegacySettingsLocked(globalSettings, database, TABLE_GLOBAL);
-                globalSettings.persistSyncLocked();
-            }
-
-            // Move over the secure settings.
-            final int secureKey = makeKey(SETTINGS_TYPE_SECURE, userId);
-            ensureSettingsStateLocked(secureKey);
-            ArielSettingsState secureSettings = mSettingsStates.get(secureKey);
-            migrateLegacySettingsLocked(secureSettings, database, TABLE_SECURE);
-            ensureSecureSettingAndroidIdSetLocked(secureSettings);
-            secureSettings.persistSyncLocked();
-
-            // Move over the system settings.
-            final int systemKey = makeKey(SETTINGS_TYPE_SYSTEM, userId);
-            ensureSettingsStateLocked(systemKey);
-            ArielSettingsState systemSettings = mSettingsStates.get(systemKey);
-            migrateLegacySettingsLocked(systemSettings, database, TABLE_SYSTEM);
-            systemSettings.persistSyncLocked();
-
-            // Drop the database as now all is moved and persisted.
-            if (DROP_DATABASE_ON_MIGRATION) {
-                dbHelper.dropDatabase();
-            } else {
-                dbHelper.backupDatabase();
-            }
-        }
-
-        private void migrateLegacySettingsLocked(ArielSettingsState settingsState,
-                SQLiteDatabase database, String table) {
-            SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();
-            queryBuilder.setTables(table);
-
-            Cursor cursor = queryBuilder.query(database, ALL_COLUMNS,
-                    null, null, null, null, null);
-
-            if (cursor == null) {
-                return;
-            }
-
-            try {
-                if (!cursor.moveToFirst()) {
-                    return;
-                }
-
-                final int nameColumnIdx = cursor.getColumnIndex(ArielSettings.NameValueTable.NAME);
-                final int valueColumnIdx = cursor.getColumnIndex(ArielSettings.NameValueTable.VALUE);
-
-                settingsState.setVersionLocked(database.getVersion());
-
-                while (!cursor.isAfterLast()) {
-                    String name = cursor.getString(nameColumnIdx);
-                    String value = cursor.getString(valueColumnIdx);
-                    settingsState.insertSettingLocked(name, value,
-                            ArielSettingsState.SYSTEM_PACKAGE_NAME);
-                    cursor.moveToNext();
-                }
-            } finally {
-                cursor.close();
-            }
-        }
-
-        private void ensureSecureSettingAndroidIdSetLocked(ArielSettingsState secureSettings) {
-
-            final int userId = getUserIdFromKey(secureSettings.mKey);
-
-            final UserInfo user;
-            final long identity = Binder.clearCallingIdentity();
-            try {
-                user = mUserManager.getUserInfo(userId);
-            } finally {
-                Binder.restoreCallingIdentity(identity);
-            }
-            if (user == null) {
-                // Can happen due to races when deleting users - treat as benign.
-                return;
-            }
-
-        }
-
-        private void notifyForSettingsChange(int key, String name) {
-            // Update the system property *first*, so if someone is listening for
-            // a notification and then using the contract class to get their data,
-            // the system property will be updated and they'll get the new data.
-
-            boolean backedUpDataChanged = false;
-            String property = null;
-            if (isGlobalSettingsKey(key)) {
-                property = ArielSettings.Global.SYS_PROP_SETTING_VERSION;
-                backedUpDataChanged = true;
-            } else if (isSecureSettingsKey(key)) {
-                property = ArielSettings.Secure.SYS_PROP_SETTING_VERSION;
-                backedUpDataChanged = true;
-            } else if (isSystemSettingsKey(key)) {
-                property = ArielSettings.System.SYS_PROP_SETTING_VERSION;
-                backedUpDataChanged = true;
-            }
-
-            if (property != null) {
-                final long version = SystemProperties.getLong(property, 0) + 1;
-                SystemProperties.set(property, Long.toString(version));
-                if (DEBUG) {
-                    Slog.v(LOG_TAG, "System property " + property + "=" + version);
-                }
-            }
-
-            // Inform the backup manager about a data change
-            if (backedUpDataChanged) {
-                mHandler.obtainMessage(MyHandler.MSG_NOTIFY_DATA_CHANGED).sendToTarget();
-            }
-
-            // Now send the notification through the content framework.
-
-            final int userId = getUserIdFromKey(key);
-            Uri uri = getNotificationUriFor(key, name);
-
-            mHandler.obtainMessage(MyHandler.MSG_NOTIFY_URI_CHANGED,
-                    userId, 0, uri).sendToTarget();
-
-            if (isSecureSettingsKey(key)) {
-                maybeNotifyProfiles(userId, uri, name, sSecureCloneToManagedSettings);
-            } else if (isSystemSettingsKey(key)) {
-                maybeNotifyProfiles(userId, uri, name, sSystemCloneToManagedSettings);
-            }
-        }
-
-        private void maybeNotifyProfiles(int userId, Uri uri, String name,
-                Set<String> keysCloned) {
-            if (keysCloned.contains(name)) {
-                List<UserInfo> profiles = mUserManager.getProfiles(userId);
-                int size = profiles.size();
-                for (int i = 0; i < size; i++) {
-                    UserInfo profile = profiles.get(i);
-                    // the notification for userId has already been sent.
-                    if (profile.id != userId) {
-                        mHandler.obtainMessage(MyHandler.MSG_NOTIFY_URI_CHANGED,
-                                profile.id, 0, uri).sendToTarget();
-                    }
-                }
-            }
-        }
-
-        private int makeKey(int type, int userId) {
-            return (type << SETTINGS_TYPE_SHIFT) | userId;
-        }
-
-        private int getTypeFromKey(int key) {
-            return key >> SETTINGS_TYPE_SHIFT;
-        }
-
-        private int getUserIdFromKey(int key) {
-            return key & ~SETTINGS_TYPE_MASK;
-        }
-
-        private boolean isGlobalSettingsKey(int key) {
-            return getTypeFromKey(key) == SETTINGS_TYPE_GLOBAL;
-        }
-
-        private boolean isSystemSettingsKey(int key) {
-            return getTypeFromKey(key) == SETTINGS_TYPE_SYSTEM;
-        }
-
-        private boolean isSecureSettingsKey(int key) {
-            return getTypeFromKey(key) == SETTINGS_TYPE_SECURE;
-        }
-
-        private File getSettingsFile(int key) {
-            if (isGlobalSettingsKey(key)) {
-                final int userId = getUserIdFromKey(key);
-                return new File(Environment.getUserSystemDirectory(userId),
-                        SETTINGS_FILE_GLOBAL);
-            } else if (isSystemSettingsKey(key)) {
-                final int userId = getUserIdFromKey(key);
-                return new File(Environment.getUserSystemDirectory(userId),
-                        SETTINGS_FILE_SYSTEM);
-            } else if (isSecureSettingsKey(key)) {
-                final int userId = getUserIdFromKey(key);
-                return new File(Environment.getUserSystemDirectory(userId),
-                        SETTINGS_FILE_SECURE);
-            } else {
-                throw new IllegalArgumentException("Invalid settings key:" + key);
-            }
-        }
-
-        private Uri getNotificationUriFor(int key, String name) {
-            if (isGlobalSettingsKey(key)) {
-                return (name != null) ? Uri.withAppendedPath(ArielSettings.Global.CONTENT_URI, name)
-                        : ArielSettings.Global.CONTENT_URI;
-            } else if (isSecureSettingsKey(key)) {
-                return (name != null) ? Uri.withAppendedPath(ArielSettings.Secure.CONTENT_URI, name)
-                        : ArielSettings.Secure.CONTENT_URI;
-            } else if (isSystemSettingsKey(key)) {
-                return (name != null) ? Uri.withAppendedPath(ArielSettings.System.CONTENT_URI, name)
-                        : ArielSettings.System.CONTENT_URI;
-            } else {
-                throw new IllegalArgumentException("Invalid settings key:" + key);
-            }
-        }
-
-        private int getMaxBytesPerPackageForType(int type) {
-            switch (type) {
-                case SETTINGS_TYPE_GLOBAL:
-                case SETTINGS_TYPE_SECURE: {
-                    return ArielSettingsState.MAX_BYTES_PER_APP_PACKAGE_UNLIMITED;
-                }
-
-                default: {
-                    return ArielSettingsState.MAX_BYTES_PER_APP_PACKAGE_LIMITED;
-                }
-            }
-        }
-
-        private final class MyHandler extends Handler {
-            private static final int MSG_NOTIFY_URI_CHANGED = 1;
-            private static final int MSG_NOTIFY_DATA_CHANGED = 2;
-
-            public MyHandler(Looper looper) {
-                super(looper);
-            }
-
-            @Override
-            public void handleMessage(Message msg) {
-                switch (msg.what) {
-                    case MSG_NOTIFY_URI_CHANGED: {
-                        final int userId = msg.arg1;
-                        Uri uri = (Uri) msg.obj;
-                        getContext().getContentResolver().notifyChange(uri, null, true, userId);
-                        if (DEBUG) {
-                            Slog.v(LOG_TAG, "Notifying for " + userId + ": " + uri);
-                        }
-                    } break;
-
-                    case MSG_NOTIFY_DATA_CHANGED: {
-                        mBackupManager.dataChanged();
-                    } break;
-                }
-            }
-        }
-
-        private final class UpgradeController {
-            private static final int SETTINGS_VERSION = 1;
-
-            private final int mUserId;
-
-            public UpgradeController(int userId) {
-                mUserId = userId;
-            }
-
-            public void upgradeIfNeededLocked() {
-                // The version of all settings for a user is the same (all users have secure).
-                ArielSettingsState secureSettings = getSettingsLocked(
-                        SettingsRegistry.SETTINGS_TYPE_SECURE, mUserId);
-
-                // Try an update from the current state.
-                final int oldVersion = secureSettings.getVersionLocked();
-                final int newVersion = SETTINGS_VERSION;
-
-                // If up do date - done.
-                if (oldVersion == newVersion) {
-                    return;
-                }
-
-                // Try to upgrade.
-                final int curVersion = onUpgradeLocked(mUserId, oldVersion, newVersion);
-
-                // If upgrade failed start from scratch and upgrade.
-                if (curVersion != newVersion) {
-                    // Drop state we have for this user.
-                    removeUserStateLocked(mUserId, true);
-
-                    // Recreate the database.
-                    DatabaseHelper dbHelper = new DatabaseHelper(getContext(), mUserId);
-                    SQLiteDatabase database = dbHelper.getWritableDatabase();
-                    dbHelper.recreateDatabase(database, newVersion, curVersion, oldVersion);
-
-                    // Migrate the settings for this user.
-                    migrateLegacySettingsForUserLocked(dbHelper, database, mUserId);
-
-                    // Now upgrade should work fine.
-                    onUpgradeLocked(mUserId, oldVersion, newVersion);
-                }
-
-                // Set the global settings version if owner.
-                if (mUserId == UserHandle.USER_OWNER) {
-                    ArielSettingsState globalSettings = getSettingsLocked(
-                            SettingsRegistry.SETTINGS_TYPE_GLOBAL, mUserId);
-                    globalSettings.setVersionLocked(newVersion);
-                }
-
-                // Set the secure settings version.
-                secureSettings.setVersionLocked(newVersion);
-
-                // Set the system settings version.
-                ArielSettingsState systemSettings = getSettingsLocked(
-                        SettingsRegistry.SETTINGS_TYPE_SYSTEM, mUserId);
-                systemSettings.setVersionLocked(newVersion);
-            }
-
-            private ArielSettingsState getGlobalSettingsLocked() {
-                return getSettingsLocked(SETTINGS_TYPE_GLOBAL, UserHandle.USER_OWNER);
-            }
-
-            private ArielSettingsState getSecureSettingsLocked(int userId) {
-                return getSettingsLocked(SETTINGS_TYPE_SECURE, userId);
-            }
-
-            private ArielSettingsState getSystemSettingsLocked(int userId) {
-                return getSettingsLocked(SETTINGS_TYPE_SYSTEM, userId);
-            }
-
-            /**
-             * You must perform all necessary mutations to bring the settings
-             * for this user from the old to the new version. When you add a new
-             * upgrade step you *must* update SETTINGS_VERSION.
-             *
-             * This is an example of moving a setting from secure to global.
-             *
-             * // v119: Example settings changes.
-             * if (currentVersion == 118) {
-             *     if (userId == UserHandle.USER_OWNER) {
-             *         // Remove from the secure settings.
-             *         SettingsState secureSettings = getSecureSettingsLocked(userId);
-             *         String name = "example_setting_to_move";
-             *         String value = secureSettings.getSetting(name);
-             *         secureSettings.deleteSetting(name);
-             *
-             *         // Add to the global settings.
-             *         SettingsState globalSettings = getGlobalSettingsLocked();
-             *         globalSettings.insertSetting(name, value, SettingsState.SYSTEM_PACKAGE_NAME);
-             *     }
-             *
-             *     // Update the current version.
-             *     currentVersion = 119;
-             * }
-             */
-            private int onUpgradeLocked(int userId, int oldVersion, int newVersion) {
-                if (DEBUG) {
-                    Slog.w(LOG_TAG, "Upgrading settings for user: " + userId + " from version: "
-                            + oldVersion + " to version: " + newVersion);
-                }
-
-                int currentVersion = oldVersion;
-
-                // vXXX: Add new settings above this point.
-
-                // Return the current version.
-                return currentVersion;
-            }
-        }
-    }
-}
diff --git a/packages/ArielSettingsProvider/src/com/android/providers/arielsettings/ArielSettingsState.java b/packages/ArielSettingsProvider/src/com/android/providers/arielsettings/ArielSettingsState.java
deleted file mode 100644
index 2d963d7..0000000
--- a/packages/ArielSettingsProvider/src/com/android/providers/arielsettings/ArielSettingsState.java
+++ /dev/null
@@ -1,658 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.providers.arielsettings;
-
-import android.os.Handler;
-import android.os.Message;
-import android.os.SystemClock;
-import android.provider.ArielSettings;
-import android.provider.Settings;
-import android.text.TextUtils;
-import android.util.ArrayMap;
-import android.util.AtomicFile;
-import android.util.Base64;
-import android.util.Slog;
-import android.util.Xml;
-import com.android.internal.annotations.GuardedBy;
-import com.android.internal.os.BackgroundThread;
-import libcore.io.IoUtils;
-import libcore.util.Objects;
-import org.xmlpull.v1.XmlPullParser;
-import org.xmlpull.v1.XmlPullParserException;
-import org.xmlpull.v1.XmlSerializer;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * This class contains the state for one type of settings. It is responsible
- * for saving the state asynchronously to an XML file after a mutation and
- * loading the from an XML file on construction.
- * <p>
- * This class uses the same lock as the settings provider to ensure that
- * multiple changes made by the settings provider, e,g, upgrade, bulk insert,
- * etc, are atomically persisted since the asynchronous persistence is using
- * the same lock to grab the current state to write to disk.
- * </p>
- */
-final class ArielSettingsState {
-    private static final boolean DEBUG = false;
-    private static final boolean DEBUG_PERSISTENCE = false;
-
-    private static final String LOG_TAG = "ArielSettingsState";
-
-    static final int SETTINGS_VERSOIN_NEW_ENCODING = 121;
-
-    private static final long WRITE_SETTINGS_DELAY_MILLIS = 200;
-    private static final long MAX_WRITE_SETTINGS_DELAY_MILLIS = 2000;
-
-    public static final int MAX_BYTES_PER_APP_PACKAGE_UNLIMITED = -1;
-    public static final int MAX_BYTES_PER_APP_PACKAGE_LIMITED = 20000;
-
-    public static final String SYSTEM_PACKAGE_NAME = "android";
-
-    public static final int VERSION_UNDEFINED = -1;
-
-    private static final String TAG_SETTINGS = "arielsettings";
-    private static final String TAG_SETTING = "arielsetting";
-    private static final String ATTR_PACKAGE = "package";
-
-    private static final String ATTR_VERSION = "version";
-    private static final String ATTR_ID = "id";
-    private static final String ATTR_NAME = "name";
-
-    /** Non-binary value will be written in this attribute. */
-    private static final String ATTR_VALUE = "value";
-
-    /**
-     * KXmlSerializer won't like some characters.  We encode such characters in base64 and
-     * store in this attribute.
-     * NOTE: A null value will have NEITHER ATTR_VALUE nor ATTR_VALUE_BASE64.
-     */
-    private static final String ATTR_VALUE_BASE64 = "valueBase64";
-
-    // This was used in version 120 and before.
-    private static final String NULL_VALUE_OLD_STYLE = "null";
-
-    private final Object mLock;
-
-    private final Handler mHandler = new MyHandler();
-
-    @GuardedBy("mLock")
-    private final ArrayMap<String, Setting> mSettings = new ArrayMap<>();
-
-    @GuardedBy("mLock")
-    private final ArrayMap<String, Integer> mPackageToMemoryUsage;
-
-    @GuardedBy("mLock")
-    private final int mMaxBytesPerAppPackage;
-
-    @GuardedBy("mLock")
-    private final File mStatePersistFile;
-
-    public final int mKey;
-
-    @GuardedBy("mLock")
-    private int mVersion = VERSION_UNDEFINED;
-
-    @GuardedBy("mLock")
-    private long mLastNotWrittenMutationTimeMillis;
-
-    @GuardedBy("mLock")
-    private boolean mDirty;
-
-    @GuardedBy("mLock")
-    private boolean mWriteScheduled;
-
-    @GuardedBy("mLock")
-    private long mNextId;
-
-    public ArielSettingsState(Object lock, File file, int key, int maxBytesPerAppPackage) {
-        // It is important that we use the same lock as the settings provider
-        // to ensure multiple mutations on this state are atomicaly persisted
-        // as the async persistence should be blocked while we make changes.
-        mLock = lock;
-        mStatePersistFile = file;
-        mKey = key;
-        if (maxBytesPerAppPackage == MAX_BYTES_PER_APP_PACKAGE_LIMITED) {
-            mMaxBytesPerAppPackage = maxBytesPerAppPackage;
-            mPackageToMemoryUsage = new ArrayMap<>();
-        } else {
-            mMaxBytesPerAppPackage = maxBytesPerAppPackage;
-            mPackageToMemoryUsage = null;
-        }
-        synchronized (mLock) {
-            readStateSyncLocked();
-        }
-    }
-
-    // The settings provider must hold its lock when calling here.
-    public int getVersionLocked() {
-        return mVersion;
-    }
-
-    // The settings provider must hold its lock when calling here.
-    public void setVersionLocked(int version) {
-        if (version == mVersion) {
-            return;
-        }
-        mVersion = version;
-
-        scheduleWriteIfNeededLocked();
-    }
-
-    // The settings provider must hold its lock when calling here.
-    public void onPackageRemovedLocked(String packageName) {
-        boolean removedSomething = false;
-
-        final int settingCount = mSettings.size();
-        for (int i = settingCount - 1; i >= 0; i--) {
-            String name = mSettings.keyAt(i);
-            // Settings defined by us are never dropped.
-            if (ArielSettings.System.PUBLIC_SETTINGS.contains(name)
-                    || ArielSettings.System.PRIVATE_SETTINGS.contains(name)) {
-                continue;
-            }
-            Setting setting = mSettings.valueAt(i);
-            if (packageName.equals(setting.packageName)) {
-                mSettings.removeAt(i);
-                removedSomething = true;
-            }
-        }
-
-        if (removedSomething) {
-            scheduleWriteIfNeededLocked();
-        }
-    }
-
-    // The settings provider must hold its lock when calling here.
-    public List<String> getSettingNamesLocked() {
-        ArrayList<String> names = new ArrayList<>();
-        final int settingsCount = mSettings.size();
-        for (int i = 0; i < settingsCount; i++) {
-            String name = mSettings.keyAt(i);
-            names.add(name);
-        }
-        return names;
-    }
-
-    // The settings provider must hold its lock when calling here.
-    public Setting getSettingLocked(String name) {
-        if (TextUtils.isEmpty(name)) {
-            return null;
-        }
-        return mSettings.get(name);
-    }
-
-    // The settings provider must hold its lock when calling here.
-    public boolean updateSettingLocked(String name, String value, String packageName) {
-        if (!hasSettingLocked(name)) {
-            return false;
-        }
-
-        return insertSettingLocked(name, value, packageName);
-    }
-
-    // The settings provider must hold its lock when calling here.
-    public boolean insertSettingLocked(String name, String value, String packageName) {
-        if (TextUtils.isEmpty(name)) {
-            return false;
-        }
-
-        Setting oldState = mSettings.get(name);
-        String oldValue = (oldState != null) ? oldState.value : null;
-
-        if (oldState != null) {
-            if (!oldState.update(value, packageName)) {
-                return false;
-            }
-        } else {
-            Setting state = new Setting(name, value, packageName);
-            mSettings.put(name, state);
-        }
-
-        updateMemoryUsagePerPackageLocked(packageName, oldValue, value);
-
-        scheduleWriteIfNeededLocked();
-
-        return true;
-    }
-
-    // The settings provider must hold its lock when calling here.
-    public void persistSyncLocked() {
-        mHandler.removeMessages(MyHandler.MSG_PERSIST_SETTINGS);
-        doWriteState();
-    }
-
-    // The settings provider must hold its lock when calling here.
-    public boolean deleteSettingLocked(String name) {
-        if (TextUtils.isEmpty(name) || !hasSettingLocked(name)) {
-            return false;
-        }
-
-        Setting oldState = mSettings.remove(name);
-
-        updateMemoryUsagePerPackageLocked(oldState.packageName, oldState.value, null);
-
-        scheduleWriteIfNeededLocked();
-
-        return true;
-    }
-
-    // The settings provider must hold its lock when calling here.
-    public void destroyLocked(Runnable callback) {
-        mHandler.removeMessages(MyHandler.MSG_PERSIST_SETTINGS);
-        if (callback != null) {
-            if (mDirty) {
-                // Do it without a delay.
-                mHandler.obtainMessage(MyHandler.MSG_PERSIST_SETTINGS,
-                        callback).sendToTarget();
-                return;
-            }
-            callback.run();
-        }
-    }
-
-    private void updateMemoryUsagePerPackageLocked(String packageName, String oldValue,
-            String newValue) {
-        if (mMaxBytesPerAppPackage == MAX_BYTES_PER_APP_PACKAGE_UNLIMITED) {
-            return;
-        }
-
-        if (SYSTEM_PACKAGE_NAME.equals(packageName)) {
-            return;
-        }
-
-        final int oldValueSize = (oldValue != null) ? oldValue.length() : 0;
-        final int newValueSize = (newValue != null) ? newValue.length() : 0;
-        final int deltaSize = newValueSize - oldValueSize;
-
-        Integer currentSize = mPackageToMemoryUsage.get(packageName);
-        final int newSize = Math.max((currentSize != null)
-                ? currentSize + deltaSize : deltaSize, 0);
-
-        if (newSize > mMaxBytesPerAppPackage) {
-            throw new IllegalStateException("You are adding too many system settings. "
-                    + "You should stop using system settings for app specific data"
-                    + " package: " + packageName);
-        }
-
-        if (DEBUG) {
-            Slog.i(LOG_TAG, "Settings for package: " + packageName
-                    + " size: " + newSize + " bytes.");
-        }
-
-        mPackageToMemoryUsage.put(packageName, newSize);
-    }
-
-    private boolean hasSettingLocked(String name) {
-        return mSettings.indexOfKey(name) >= 0;
-    }
-
-    private void scheduleWriteIfNeededLocked() {
-        // If dirty then we have a write already scheduled.
-        if (!mDirty) {
-            mDirty = true;
-            writeStateAsyncLocked();
-        }
-    }
-
-    private void writeStateAsyncLocked() {
-        final long currentTimeMillis = SystemClock.uptimeMillis();
-
-        if (mWriteScheduled) {
-            mHandler.removeMessages(MyHandler.MSG_PERSIST_SETTINGS);
-
-            // If enough time passed, write without holding off anymore.
-            final long timeSinceLastNotWrittenMutationMillis = currentTimeMillis
-                    - mLastNotWrittenMutationTimeMillis;
-            if (timeSinceLastNotWrittenMutationMillis >= MAX_WRITE_SETTINGS_DELAY_MILLIS) {
-                mHandler.obtainMessage(MyHandler.MSG_PERSIST_SETTINGS).sendToTarget();
-                return;
-            }
-
-            // Hold off a bit more as settings are frequently changing.
-            final long maxDelayMillis = Math.max(mLastNotWrittenMutationTimeMillis
-                    + MAX_WRITE_SETTINGS_DELAY_MILLIS - currentTimeMillis, 0);
-            final long writeDelayMillis = Math.min(WRITE_SETTINGS_DELAY_MILLIS, maxDelayMillis);
-
-            Message message = mHandler.obtainMessage(MyHandler.MSG_PERSIST_SETTINGS);
-            mHandler.sendMessageDelayed(message, writeDelayMillis);
-        } else {
-            mLastNotWrittenMutationTimeMillis = currentTimeMillis;
-            Message message = mHandler.obtainMessage(MyHandler.MSG_PERSIST_SETTINGS);
-            mHandler.sendMessageDelayed(message, WRITE_SETTINGS_DELAY_MILLIS);
-            mWriteScheduled = true;
-        }
-    }
-
-    private void doWriteState() {
-        if (DEBUG_PERSISTENCE) {
-            Slog.i(LOG_TAG, "[PERSIST START]");
-        }
-
-        AtomicFile destination = new AtomicFile(mStatePersistFile);
-
-        final int version;
-        final ArrayMap<String, Setting> settings;
-
-        synchronized (mLock) {
-            version = mVersion;
-            settings = new ArrayMap<>(mSettings);
-            mDirty = false;
-            mWriteScheduled = false;
-        }
-
-        FileOutputStream out = null;
-        try {
-            out = destination.startWrite();
-
-            XmlSerializer serializer = Xml.newSerializer();
-            serializer.setOutput(out, StandardCharsets.UTF_8.name());
-            serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
-            serializer.startDocument(null, true);
-            serializer.startTag(null, TAG_SETTINGS);
-            serializer.attribute(null, ATTR_VERSION, String.valueOf(version));
-
-            final int settingCount = settings.size();
-            for (int i = 0; i < settingCount; i++) {
-                Setting setting = settings.valueAt(i);
-
-                writeSingleSetting(mVersion, serializer, setting.getId(), setting.getName(),
-                        setting.getValue(), setting.getPackageName());
-
-                if (DEBUG_PERSISTENCE) {
-                    Slog.i(LOG_TAG, "[PERSISTED]" + setting.getName() + "=" + setting.getValue());
-                }
-            }
-
-            serializer.endTag(null, TAG_SETTINGS);
-            serializer.endDocument();
-            destination.finishWrite(out);
-
-            if (DEBUG_PERSISTENCE) {
-                Slog.i(LOG_TAG, "[PERSIST END]");
-            }
-
-            // Any error while writing is fatal.
-        } catch (Throwable t) {
-            Slog.wtf(LOG_TAG, "Failed to write settings, restoring backup", t);
-            destination.failWrite(out);
-            throw new IllegalStateException("Failed to write settings, restoring backup", t);
-        } finally {
-            IoUtils.closeQuietly(out);
-        }
-    }
-
-    static void writeSingleSetting(int version, XmlSerializer serializer, String id,
-            String name, String value, String packageName) throws IOException {
-        if (id == null || isBinary(id) || name == null || isBinary(name)
-                || packageName == null || isBinary(packageName)) {
-            // This shouldn't happen.
-            return;
-        }
-        serializer.startTag(null, TAG_SETTING);
-        serializer.attribute(null, ATTR_ID, id);
-        serializer.attribute(null, ATTR_NAME, name);
-        setValueAttribute(version, serializer, value);
-        serializer.attribute(null, ATTR_PACKAGE, packageName);
-        serializer.endTag(null, TAG_SETTING);
-    }
-
-    static void setValueAttribute(int version, XmlSerializer serializer, String value)
-            throws IOException {
-        if (version >= SETTINGS_VERSOIN_NEW_ENCODING) {
-            if (value == null) {
-                // Null value -> No ATTR_VALUE nor ATTR_VALUE_BASE64.
-            } else if (isBinary(value)) {
-                serializer.attribute(null, ATTR_VALUE_BASE64, base64Encode(value));
-            } else {
-                serializer.attribute(null, ATTR_VALUE, value);
-            }
-        } else {
-            // Old encoding.
-            if (value == null) {
-                serializer.attribute(null, ATTR_VALUE, NULL_VALUE_OLD_STYLE);
-            } else {
-                serializer.attribute(null, ATTR_VALUE, value);
-            }
-        }
-    }
-
-    private String getValueAttribute(XmlPullParser parser) {
-        if (mVersion >= SETTINGS_VERSOIN_NEW_ENCODING) {
-            final String value = parser.getAttributeValue(null, ATTR_VALUE);
-            if (value != null) {
-                return value;
-            }
-            final String base64 = parser.getAttributeValue(null, ATTR_VALUE_BASE64);
-            if (base64 != null) {
-                return base64Decode(base64);
-            }
-            // null has neither ATTR_VALUE nor ATTR_VALUE_BASE64.
-            return null;
-        } else {
-            // Old encoding.
-            final String stored = parser.getAttributeValue(null, ATTR_VALUE);
-            if (NULL_VALUE_OLD_STYLE.equals(stored)) {
-                return null;
-            } else {
-                return stored;
-            }
-        }
-    }
-
-    private void readStateSyncLocked() {
-        FileInputStream in;
-        if (!mStatePersistFile.exists()) {
-            return;
-        }
-        try {
-            in = new AtomicFile(mStatePersistFile).openRead();
-        } catch (FileNotFoundException fnfe) {
-            Slog.i(LOG_TAG, "No settings state");
-            return;
-        }
-        try {
-            XmlPullParser parser = Xml.newPullParser();
-            parser.setInput(in, StandardCharsets.UTF_8.name());
-            parseStateLocked(parser);
-
-        } catch (XmlPullParserException | IOException e) {
-            throw new IllegalStateException("Failed parsing settings file: "
-                    + mStatePersistFile , e);
-        } finally {
-            IoUtils.closeQuietly(in);
-        }
-    }
-
-    private void parseStateLocked(XmlPullParser parser)
-            throws IOException, XmlPullParserException {
-        final int outerDepth = parser.getDepth();
-        int type;
-        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
-                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
-            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
-                continue;
-            }
-
-            String tagName = parser.getName();
-            if (tagName.equals(TAG_SETTINGS)) {
-                parseSettingsLocked(parser);
-            }
-        }
-    }
-
-    private void parseSettingsLocked(XmlPullParser parser)
-            throws IOException, XmlPullParserException {
-
-        mVersion = Integer.parseInt(parser.getAttributeValue(null, ATTR_VERSION));
-
-        final int outerDepth = parser.getDepth();
-        int type;
-        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
-                && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
-            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
-                continue;
-            }
-
-            String tagName = parser.getName();
-            if (tagName.equals(TAG_SETTING)) {
-                String id = parser.getAttributeValue(null, ATTR_ID);
-                String name = parser.getAttributeValue(null, ATTR_NAME);
-                String value = getValueAttribute(parser);
-                String packageName = parser.getAttributeValue(null, ATTR_PACKAGE);
-                mSettings.put(name, new Setting(name, value, packageName, id));
-
-                if (DEBUG_PERSISTENCE) {
-                    Slog.i(LOG_TAG, "[RESTORED] " + name + "=" + value);
-                }
-            }
-        }
-    }
-
-    private final class MyHandler extends Handler {
-        public static final int MSG_PERSIST_SETTINGS = 1;
-
-        public MyHandler() {
-            super(BackgroundThread.getHandler().getLooper());
-        }
-
-        @Override
-        public void handleMessage(Message message) {
-            switch (message.what) {
-                case MSG_PERSIST_SETTINGS: {
-                    Runnable callback = (Runnable) message.obj;
-                    doWriteState();
-                    if (callback != null) {
-                        callback.run();
-                    }
-                }
-                break;
-            }
-        }
-    }
-
-    public final class Setting {
-        private String name;
-        private String value;
-        private String packageName;
-        private String id;
-
-        public Setting(String name, String value, String packageName) {
-            init(name, value, packageName, String.valueOf(mNextId++));
-        }
-
-        public Setting(String name, String value, String packageName, String id) {
-            mNextId = Math.max(mNextId, Long.valueOf(id) + 1);
-            init(name, value, packageName, id);
-        }
-
-        private void init(String name, String value, String packageName, String id) {
-            this.name = name;
-            this.value = value;
-            this.packageName = packageName;
-            this.id = id;
-        }
-
-        public String getName() {
-            return name;
-        }
-
-        public String getValue() {
-            return value;
-        }
-
-        public String getPackageName() {
-            return packageName;
-        }
-
-        public String getId() {
-            return id;
-        }
-
-        public boolean update(String value, String packageName) {
-            if (Objects.equal(value, this.value)) {
-                return false;
-            }
-            this.value = value;
-            this.packageName = packageName;
-            this.id = String.valueOf(mNextId++);
-            return true;
-        }
-    }
-
-    /**
-     * @return TRUE if a string is considered "binary" from KXML's point of view.  NOTE DO NOT
-     * pass null.
-     */
-    public static boolean isBinary(String s) {
-        if (s == null) {
-            throw new NullPointerException();
-        }
-        // See KXmlSerializer.writeEscaped
-        for (int i = 0; i < s.length(); i++) {
-            char c = s.charAt(i);
-            boolean allowedInXml = (c >= 0x20 && c <= 0xd7ff) || (c >= 0xe000 && c <= 0xfffd);
-            if (!allowedInXml) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private static String base64Encode(String s) {
-        return Base64.encodeToString(toBytes(s), Base64.NO_WRAP);
-    }
-
-    private static String base64Decode(String s) {
-        return fromBytes(Base64.decode(s, Base64.DEFAULT));
-    }
-
-    // Note the followings are basically just UTF-16 encode/decode.  But we want to preserve
-    // contents as-is, even if it contains broken surrogate pairs, we do it by ourselves,
-    // since I don't know how Charset would treat them.
-
-    private static byte[] toBytes(String s) {
-        final byte[] result = new byte[s.length() * 2];
-        int resultIndex = 0;
-        for (int i = 0; i < s.length(); ++i) {
-            char ch = s.charAt(i);
-            result[resultIndex++] = (byte) (ch >> 8);
-            result[resultIndex++] = (byte) ch;
-        }
-        return result;
-    }
-
-    private static String fromBytes(byte[] bytes) {
-        final StringBuffer sb = new StringBuffer(bytes.length / 2);
-
-        final int last = bytes.length - 1;
-
-        for (int i = 0; i < last; i += 2) {
-            final char ch = (char) ((bytes[i] & 0xff) << 8 | (bytes[i + 1] & 0xff));
-            sb.append(ch);
-        }
-        return sb.toString();
-    }
-}
diff --git a/packages/ArielSettingsProvider/src/com/android/providers/arielsettings/DatabaseHelper.java b/packages/ArielSettingsProvider/src/com/android/providers/arielsettings/DatabaseHelper.java
deleted file mode 100644
index c7b4940..0000000
--- a/packages/ArielSettingsProvider/src/com/android/providers/arielsettings/DatabaseHelper.java
+++ /dev/null
@@ -1,521 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.providers.arielsettings;
-
-import android.content.ComponentName;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.ActivityInfo;
-import android.content.pm.IPackageManager;
-import android.content.pm.PackageManager;
-import android.content.res.XmlResourceParser;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.database.sqlite.SQLiteStatement;
-import android.media.AudioSystem;
-import android.media.AudioManager;
-import android.net.ConnectivityManager;
-import android.os.Build;
-import android.os.Environment;
-import android.os.RemoteException;
-import android.os.ServiceManager;
-import android.os.SystemProperties;
-import android.os.UserHandle;
-import android.provider.ArielSettings;
-import android.provider.ArielSettings.Global;
-import android.provider.ArielSettings.Secure;
-import android.text.TextUtils;
-import android.util.Log;
-
-import com.android.ims.ImsConfig;
-import com.android.internal.content.PackageHelper;
-import com.android.internal.telephony.RILConstants;
-import com.android.internal.telephony.cdma.CdmaSubscriptionSourceManager;
-import com.android.internal.util.XmlUtils;
-import com.android.internal.widget.LockPatternUtils;
-import com.android.internal.widget.LockPatternView;
-
-import org.xmlpull.v1.XmlPullParser;
-import org.xmlpull.v1.XmlPullParserException;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-/**
- * Legacy settings database helper class for {@link SettingsProvider}.
- *
- * IMPORTANT: Do not add any more upgrade steps here as the global,
- * secure, and system settings are no longer stored in a database
- * but are kept in memory and persisted to XML.
- *
- * See: SettingsProvider.UpgradeController#onUpgradeLocked
- *
- * @deprecated The implementation is frozen.  Do not add any new code to this class!
- */
-@Deprecated
-class DatabaseHelper extends SQLiteOpenHelper {
-    private static final String TAG = "ArielSettingsProvider";
-    private static final String DATABASE_NAME = "ariel_settings.db";
-
-    // Please, please please. If you update the database version, check to make sure the
-    // database gets upgraded properly. At a minimum, please confirm that 'upgradeVersion'
-    // is properly propagated through your change.  Not doing so will result in a loss of user
-    // ArielSettings.
-    private static final int DATABASE_VERSION = 1;
-
-    private Context mContext;
-    private int mUserHandle;
-
-    private static final HashSet<String> mValidTables = new HashSet<String>();
-
-    private static final String DATABASE_JOURNAL_SUFFIX = "-journal";
-    private static final String DATABASE_BACKUP_SUFFIX = "-backup";
-
-    private static final String TABLE_SYSTEM = "system";
-    private static final String TABLE_SECURE = "secure";
-    private static final String TABLE_GLOBAL = "global";
-
-    static {
-        mValidTables.add(TABLE_SYSTEM);
-        mValidTables.add(TABLE_SECURE);
-        mValidTables.add(TABLE_GLOBAL);
-    }
-
-    static String dbNameForUser(final int userHandle) {
-        // The owner gets the unadorned db name;
-        if (userHandle == UserHandle.USER_OWNER) {
-            return DATABASE_NAME;
-        } else {
-            // Place the database in the user-specific data tree so that it's
-            // cleaned up automatically when the user is deleted.
-            File databaseFile = new File(
-                    Environment.getUserSystemDirectory(userHandle), DATABASE_NAME);
-            return databaseFile.getPath();
-        }
-    }
-
-    public DatabaseHelper(Context context, int userHandle) {
-        super(context, dbNameForUser(userHandle), null, DATABASE_VERSION);
-        mContext = context;
-        mUserHandle = userHandle;
-    }
-
-    public static boolean isValidTable(String name) {
-        return mValidTables.contains(name);
-    }
-
-    public void dropDatabase() {
-        close();
-        File databaseFile = mContext.getDatabasePath(getDatabaseName());
-        if (databaseFile.exists()) {
-            databaseFile.delete();
-        }
-        File databaseJournalFile = mContext.getDatabasePath(getDatabaseName()
-                + DATABASE_JOURNAL_SUFFIX);
-        if (databaseJournalFile.exists()) {
-            databaseJournalFile.delete();
-        }
-    }
-
-    public void backupDatabase() {
-        close();
-        File databaseFile = mContext.getDatabasePath(getDatabaseName());
-        if (!databaseFile.exists()) {
-            return;
-        }
-        File backupFile = mContext.getDatabasePath(getDatabaseName()
-                + DATABASE_BACKUP_SUFFIX);
-        if (backupFile.exists()) {
-            return;
-        }
-        databaseFile.renameTo(backupFile);
-    }
-
-    private void createSecureTable(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE secure (" +
-                "_id INTEGER PRIMARY KEY AUTOINCREMENT," +
-                "name TEXT UNIQUE ON CONFLICT REPLACE," +
-                "value TEXT" +
-                ");");
-        db.execSQL("CREATE INDEX secureIndex1 ON secure (name);");
-    }
-
-    private void createGlobalTable(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE global (" +
-                "_id INTEGER PRIMARY KEY AUTOINCREMENT," +
-                "name TEXT UNIQUE ON CONFLICT REPLACE," +
-                "value TEXT" +
-                ");");
-        db.execSQL("CREATE INDEX globalIndex1 ON global (name);");
-    }
-
-    @Override
-    public void onCreate(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE system (" +
-                    "_id INTEGER PRIMARY KEY AUTOINCREMENT," +
-                    "name TEXT UNIQUE ON CONFLICT REPLACE," +
-                    "value TEXT" +
-                    ");");
-        db.execSQL("CREATE INDEX systemIndex1 ON system (name);");
-
-        createSecureTable(db);
-
-        // Only create the global table for the singleton 'owner' user
-        if (mUserHandle == UserHandle.USER_OWNER) {
-            createGlobalTable(db);
-        }
-
-        db.execSQL("CREATE TABLE bluetooth_devices (" +
-                    "_id INTEGER PRIMARY KEY," +
-                    "name TEXT," +
-                    "addr TEXT," +
-                    "channel INTEGER," +
-                    "type INTEGER" +
-                    ");");
-
-        db.execSQL("CREATE TABLE bookmarks (" +
-                    "_id INTEGER PRIMARY KEY," +
-                    "title TEXT," +
-                    "folder TEXT," +
-                    "intent TEXT," +
-                    "shortcut INTEGER," +
-                    "ordering INTEGER" +
-                    ");");
-
-        db.execSQL("CREATE INDEX bookmarksIndex1 ON bookmarks (folder);");
-        db.execSQL("CREATE INDEX bookmarksIndex2 ON bookmarks (shortcut);");
-
-        // Populate bookmarks table with initial bookmarks
-        boolean onlyCore = false;
-        try {
-            onlyCore = IPackageManager.Stub.asInterface(ServiceManager.getService(
-                    "package")).isOnlyCoreApps();
-        } catch (RemoteException e) {
-        }
-
-        // Load inital settings values
-        loadSettings(db);
-    }
-
-    @Override
-    public void onUpgrade(SQLiteDatabase db, int oldVersion, int currentVersion) {
-        Log.w(TAG, "Upgrading settings database from version " + oldVersion + " to "
-                + currentVersion);
-
-        int upgradeVersion = oldVersion;
-
-        // Pattern for upgrade blocks:
-        //
-        //    if (upgradeVersion == [the DATABASE_VERSION you set] - 1) {
-        //        .. your upgrade logic..
-        //        upgradeVersion = [the DATABASE_VERSION you set]
-        //    }
-
-//        if (upgradeVersion == 36) {
-//           // This upgrade adds the STREAM_SYSTEM_ENFORCED type to the list of
-//            // types affected by ringer modes (silent, vibrate, etc.)
-//            db.beginTransaction();
-//            try {
-//                db.execSQL("DELETE FROM system WHERE name='"
-//                        + ArielSettings.System.MODE_RINGER_STREAMS_AFFECTED + "'");
-//                int newValue = (1 << AudioManager.STREAM_RING)
-//                        | (1 << AudioManager.STREAM_NOTIFICATION)
-//                        | (1 << AudioManager.STREAM_SYSTEM)
-//                        | (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
-//                db.execSQL("INSERT INTO system ('name', 'value') values ('"
-//                        + ArielSettings.System.MODE_RINGER_STREAMS_AFFECTED + "', '"
-//                        + String.valueOf(newValue) + "')");
-//                db.setTransactionSuccessful();
-//            } finally {
-//                db.endTransaction();
-//            }
-//            upgradeVersion = 37;
-//        }
-
-        /*
-         * IMPORTANT: Do not add any more upgrade steps here as the global,
-         * secure, and system settings are no longer stored in a database
-         * but are kept in memory and persisted to XML.
-         *
-         * See: SettingsProvider.UpgradeController#onUpgradeLocked
-         */
-
-        if (upgradeVersion != currentVersion) {
-            recreateDatabase(db, oldVersion, upgradeVersion, currentVersion);
-        }
-    }
-
-    public void recreateDatabase(SQLiteDatabase db, int oldVersion,
-            int upgradeVersion, int currentVersion) {
-        db.execSQL("DROP TABLE IF EXISTS global");
-        db.execSQL("DROP TABLE IF EXISTS globalIndex1");
-        db.execSQL("DROP TABLE IF EXISTS system");
-        db.execSQL("DROP INDEX IF EXISTS systemIndex1");
-        db.execSQL("DROP TABLE IF EXISTS secure");
-        db.execSQL("DROP INDEX IF EXISTS secureIndex1");
-        db.execSQL("DROP TABLE IF EXISTS gservices");
-        db.execSQL("DROP INDEX IF EXISTS gservicesIndex1");
-        db.execSQL("DROP TABLE IF EXISTS bluetooth_devices");
-        db.execSQL("DROP TABLE IF EXISTS bookmarks");
-        db.execSQL("DROP INDEX IF EXISTS bookmarksIndex1");
-        db.execSQL("DROP INDEX IF EXISTS bookmarksIndex2");
-        db.execSQL("DROP TABLE IF EXISTS favorites");
-
-        onCreate(db);
-
-        // Added for diagnosing ArielSettings.db wipes after the fact
-        String wipeReason = oldVersion + "/" + upgradeVersion + "/" + currentVersion;
-        db.execSQL("INSERT INTO secure(name,value) values('" +
-                "wiped_db_reason" + "','" + wipeReason + "');");
-    }
-
-    private String[] setToStringArray(Set<String> set) {
-        String[] array = new String[set.size()];
-        return set.toArray(array);
-    }
-
-    private void moveSettingsToNewTable(SQLiteDatabase db,
-            String sourceTable, String destTable,
-            String[] settingsToMove, boolean doIgnore) {
-        // Copy settings values from the source table to the dest, and remove from the source
-        SQLiteStatement insertStmt = null;
-        SQLiteStatement deleteStmt = null;
-
-        db.beginTransaction();
-        try {
-            insertStmt = db.compileStatement("INSERT "
-                    + (doIgnore ? " OR IGNORE " : "")
-                    + " INTO " + destTable + " (name,value) SELECT name,value FROM "
-                    + sourceTable + " WHERE name=?");
-            deleteStmt = db.compileStatement("DELETE FROM " + sourceTable + " WHERE name=?");
-
-            for (String setting : settingsToMove) {
-                insertStmt.bindString(1, setting);
-                insertStmt.execute();
-
-                deleteStmt.bindString(1, setting);
-                deleteStmt.execute();
-            }
-            db.setTransactionSuccessful();
-        } finally {
-            db.endTransaction();
-            if (insertStmt != null) {
-                insertStmt.close();
-            }
-            if (deleteStmt != null) {
-                deleteStmt.close();
-            }
-        }
-    }
-
-    /**
-     * Move any settings with the given prefixes from the source table to the
-     * destination table.
-     */
-    private void movePrefixedSettingsToNewTable(
-            SQLiteDatabase db, String sourceTable, String destTable, String[] prefixesToMove) {
-        SQLiteStatement insertStmt = null;
-        SQLiteStatement deleteStmt = null;
-
-        db.beginTransaction();
-        try {
-            insertStmt = db.compileStatement("INSERT INTO " + destTable
-                    + " (name,value) SELECT name,value FROM " + sourceTable
-                    + " WHERE substr(name,0,?)=?");
-            deleteStmt = db.compileStatement(
-                    "DELETE FROM " + sourceTable + " WHERE substr(name,0,?)=?");
-
-            for (String prefix : prefixesToMove) {
-                insertStmt.bindLong(1, prefix.length() + 1);
-                insertStmt.bindString(2, prefix);
-                insertStmt.execute();
-
-                deleteStmt.bindLong(1, prefix.length() + 1);
-                deleteStmt.bindString(2, prefix);
-                deleteStmt.execute();
-            }
-            db.setTransactionSuccessful();
-        } finally {
-            db.endTransaction();
-            if (insertStmt != null) {
-                insertStmt.close();
-            }
-            if (deleteStmt != null) {
-                deleteStmt.close();
-            }
-        }
-    }
-
-//    private void upgradeScreenTimeoutFromNever(SQLiteDatabase db) {
-//        // See if the timeout is -1 (for "Never").
-//        Cursor c = db.query(TABLE_SYSTEM, new String[] { "_id", "value" }, "name=? AND value=?",
-//                new String[] { ArielSettings.System.SCREEN_OFF_TIMEOUT, "-1" },
-//                null, null, null);
-//
-//        SQLiteStatement stmt = null;
-//        if (c.getCount() > 0) {
-//            c.close();
-//            try {
-//                stmt = db.compileStatement("INSERT OR REPLACE INTO system(name,value)"
-//                        + " VALUES(?,?);");
-//
-//                // Set the timeout to 30 minutes in milliseconds
-//                loadSetting(stmt, ArielSettings.System.SCREEN_OFF_TIMEOUT,
-//                        Integer.toString(30 * 60 * 1000));
-//            } finally {
-//                if (stmt != null) stmt.close();
-//            }
-//        } else {
-//            c.close();
-//        }
-//    }
-
-    private void loadSettings(SQLiteDatabase db) {
-        loadSystemSettings(db);
-        loadSecureSettings(db);
-        // The global table only exists for the 'owner' user
-        if (mUserHandle == UserHandle.USER_OWNER) {
-            loadGlobalSettings(db);
-        }
-    }
-
-    private void loadSystemSettings(SQLiteDatabase db) {
-        SQLiteStatement stmt = null;
-        try {
-            stmt = db.compileStatement("INSERT OR IGNORE INTO system(name,value)"
-                    + " VALUES(?,?);");
-
-//            loadBooleanSetting(stmt, ArielSettings.System.DIM_SCREEN,
-//                    R.bool.def_dim_screen);
-//            loadIntegerSetting(stmt, ArielSettings.System.SCREEN_OFF_TIMEOUT,
-//                    R.integer.def_screen_off_timeout);
-//
-//            // Set default cdma DTMF type
-//            loadSetting(stmt, ArielSettings.System.DTMF_TONE_TYPE_WHEN_DIALING, 0);
-
-            /*
-             * IMPORTANT: Do not add any more upgrade steps here as the global,
-             * secure, and system settings are no longer stored in a database
-             * but are kept in memory and persisted to XML.
-             *
-             * See: SettingsProvider.UpgradeController#onUpgradeLocked
-             */
-        } finally {
-            if (stmt != null) stmt.close();
-        }
-    }
-
-    private void loadSecureSettings(SQLiteDatabase db) {
-        SQLiteStatement stmt = null;
-        try {
-            stmt = db.compileStatement("INSERT OR IGNORE INTO secure(name,value)"
-                    + " VALUES(?,?);");
-
-//            loadStringSetting(stmt, ArielSettings.Secure.LOCATION_PROVIDERS_ALLOWED,
-//                    R.string.def_location_providers_allowed);
-
-            /*
-             * IMPORTANT: Do not add any more upgrade steps here as the global,
-             * secure, and system settings are no longer stored in a database
-             * but are kept in memory and persisted to XML.
-             *
-             * See: SettingsProvider.UpgradeController#onUpgradeLocked
-             */
-        } finally {
-            if (stmt != null) stmt.close();
-        }
-    }
-
-    private void loadGlobalSettings(SQLiteDatabase db) {
-        SQLiteStatement stmt = null;
-        try {
-            stmt = db.compileStatement("INSERT OR IGNORE INTO global(name,value)"
-                    + " VALUES(?,?);");
-
-//            // --- Previously in 'system'
-//            loadBooleanSetting(stmt, ArielSettings.Global.AIRPLANE_MODE_ON,
-//                    R.bool.def_airplane_mode_on);
-
-            /*
-             * IMPORTANT: Do not add any more upgrade steps here as the global,
-             * secure, and system settings are no longer stored in a database
-             * but are kept in memory and persisted to XML.
-             *
-             * See: SettingsProvider.UpgradeController#onUpgradeLocked
-             */
-        } finally {
-            if (stmt != null) stmt.close();
-        }
-    }
-
-    private void loadSetting(SQLiteStatement stmt, String key, Object value) {
-        stmt.bindString(1, key);
-        stmt.bindString(2, value.toString());
-        stmt.execute();
-    }
-
-    private void loadStringSetting(SQLiteStatement stmt, String key, int resid) {
-        loadSetting(stmt, key, mContext.getResources().getString(resid));
-    }
-
-    private void loadBooleanSetting(SQLiteStatement stmt, String key, int resid) {
-        loadSetting(stmt, key,
-                mContext.getResources().getBoolean(resid) ? "1" : "0");
-    }
-
-    private void loadIntegerSetting(SQLiteStatement stmt, String key, int resid) {
-        loadSetting(stmt, key,
-                Integer.toString(mContext.getResources().getInteger(resid)));
-    }
-
-    private void loadFractionSetting(SQLiteStatement stmt, String key, int resid, int base) {
-        loadSetting(stmt, key,
-                Float.toString(mContext.getResources().getFraction(resid, base, base)));
-    }
-
-    private int getIntValueFromSystem(SQLiteDatabase db, String name, int defaultValue) {
-        return getIntValueFromTable(db, TABLE_SYSTEM, name, defaultValue);
-    }
-
-    private int getIntValueFromTable(SQLiteDatabase db, String table, String name,
-            int defaultValue) {
-        String value = getStringValueFromTable(db, table, name, null);
-        return (value != null) ? Integer.parseInt(value) : defaultValue;
-    }
-
-    private String getStringValueFromTable(SQLiteDatabase db, String table, String name,
-            String defaultValue) {
-        Cursor c = null;
-        try {
-            c = db.query(table, new String[] { ArielSettings.System.VALUE }, "name='" + name + "'",
-                    null, null, null, null);
-            if (c != null && c.moveToFirst()) {
-                String val = c.getString(0);
-                return val == null ? defaultValue : val;
-            }
-        } finally {
-            if (c != null) c.close();
-        }
-        return defaultValue;
-    }
-
-}
diff --git a/packages/ArielSettingsProvider/src/com/android/providers/arielsettings/EventLogTags.logtags b/packages/ArielSettingsProvider/src/com/android/providers/arielsettings/EventLogTags.logtags
deleted file mode 100644
index abb0960..0000000
--- a/packages/ArielSettingsProvider/src/com/android/providers/arielsettings/EventLogTags.logtags
+++ /dev/null
@@ -1,5 +0,0 @@
-# See system/core/logcat/e for a description of the format of this file.
-
-option java_package com.android.providers.arielsettings;
-
-52100 unsupported_settings_query (uri|3),(selection|3),(whereArgs|3)
diff --git a/packages/ArielSettingsProvider/test/Android.mk b/packages/ArielSettingsProvider/test/Android.mk
deleted file mode 100644
index 09bd999..0000000
--- a/packages/ArielSettingsProvider/test/Android.mk
+++ /dev/null
@@ -1,16 +0,0 @@
-LOCAL_PATH:= $(call my-dir)
-
-include $(CLEAR_VARS)
-
-# Note we statically link SettingsState to do some unit tests.  It's not accessible otherwise
-# because this test is not an instrumentation test. (because the target runs in the system process.)
-LOCAL_SRC_FILES := $(call all-subdir-java-files) \
-    ../src/com/android/providers/arielsettings/ArielSettingsState.java
-
-LOCAL_PACKAGE_NAME := ArielSettingsProviderTest
-
-LOCAL_MODULE_TAGS := tests
-
-LOCAL_CERTIFICATE := platform
-
-include $(BUILD_PACKAGE)
diff --git a/packages/ArielSettingsProvider/test/AndroidManifest.xml b/packages/ArielSettingsProvider/test/AndroidManifest.xml
deleted file mode 100644
index fa6dcd1..0000000
--- a/packages/ArielSettingsProvider/test/AndroidManifest.xml
+++ /dev/null
@@ -1,35 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (C) 2015 The Android Open Source Project
-
-     Licensed under the Apache License, Version 2.0 (the "License");
-     you may not use this file except in compliance with the License.
-     You may obtain a copy of the License at
-
-          http://www.apache.org/licenses/LICENSE-2.0
-
-     Unless required by applicable law or agreed to in writing, software
-     distributed under the License is distributed on an "AS IS" BASIS,
-     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-     See the License for the specific language governing permissions and
-     limitations under the License.
--->
-
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-          package="com.android.providers.arielsetting.test">
-
-    <uses-sdk android:minSdkVersion="21" android:targetSdkVersion="21" />
-
-    <uses-permission android:name="android.permission.WRITE_SETTINGS"/>
-    <uses-permission android:name="android.permission.WRITE_SECURE_SETTINGS"/>
-    <uses-permission android:name="android.permission.INTERACT_ACROSS_USERS_FULL"/>
-    <uses-permission android:name="android.permission.MANAGE_USERS"/>
-
-    <application>
-        <uses-library android:name="android.test.runner" />
-    </application>
-
-    <instrumentation
-        android:name="android.test.InstrumentationTestRunner"
-        android:targetPackage="com.android.providers.arielsetting.test"
-        android:label="Ariel Settings Provider Tests" />
-</manifest>
diff --git a/services/core/Android.mk b/services/core/Android.mk
index 666f2ff..e2d9c3d 100644
--- a/services/core/Android.mk
+++ b/services/core/Android.mk
@@ -10,6 +10,7 @@ LOCAL_SRC_FILES += \
     java/com/android/server/am/EventLogTags.logtags
 
 LOCAL_JAVA_LIBRARIES := services.net telephony-common
-LOCAL_STATIC_JAVA_LIBRARIES := tzdata_update
+LOCAL_STATIC_JAVA_LIBRARIES := tzdata_update \
+                               com.ariel.platform.internal
 
 include $(BUILD_STATIC_JAVA_LIBRARY)
diff --git a/services/core/java/com/android/server/am/ActiveServices.java b/services/core/java/com/android/server/am/ActiveServices.java
index 970f1b5..f9e8f7c 100755
--- a/services/core/java/com/android/server/am/ActiveServices.java
+++ b/services/core/java/com/android/server/am/ActiveServices.java
@@ -330,6 +330,9 @@ public final class ActiveServices {
         if (res == null) {
             return null;
         }
+        if (res.forwarded) {
+            return service.getComponent();
+        }
         if (res.record == null) {
             return new ComponentName("!", res.permission != null
                     ? res.permission : "private to package");
@@ -494,6 +497,9 @@ public final class ActiveServices {
         ServiceLookupResult r = retrieveServiceLocked(service, resolvedType, null,
                 Binder.getCallingPid(), Binder.getCallingUid(), userId, false, false);
         if (r != null) {
+            if (r.forwarded == true) {
+                return 1;
+            }
             if (r.record != null) {
                 final long origId = Binder.clearCallingIdentity();
                 try {
@@ -755,6 +761,9 @@ public final class ActiveServices {
         if (res.record == null) {
             return -1;
         }
+        if (res.forwarded == true) {
+            return 1;
+        }
         ServiceRecord s = res.record;
 
         final long origId = Binder.clearCallingIdentity();
@@ -1001,10 +1010,18 @@ public final class ActiveServices {
     private final class ServiceLookupResult {
         final ServiceRecord record;
         final String permission;
+        final boolean forwarded;
 
         ServiceLookupResult(ServiceRecord _record, String _permission) {
             record = _record;
             permission = _permission;
+            forwarded = false;
+        }
+
+        ServiceLookupResult(ServiceRecord _record, String _permission, boolean _forwarded) {
+            record = _record;
+            permission = _permission;
+            forwarded = _forwarded;
         }
     }
 
@@ -1125,10 +1142,20 @@ public final class ActiveServices {
                 }
             }
 
-            if (!mAm.mIntentFirewall.checkService(r.name, service, callingUid, callingPid,
-                    resolvedType, r.appInfo)) {
+//            if (!mAm.mIntentFirewall.checkService(r.name, service, callingUid, callingPid,
+//                    resolvedType, r.appInfo)) {
+//                return null;
+//            }
+//            return new ServiceLookupResult(r, null);
+
+            int ifw = mAm.mIntentFirewall.checkService(r.name, service, callingUid, callingPid,
+                    resolvedType, r.appInfo);
+            if (ifw == 1) { //block
                 return null;
             }
+            if (ifw == 2) { //forwarded
+                return new ServiceLookupResult(r, null, true);
+            }
             return new ServiceLookupResult(r, null);
         }
         return null;
diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index 33d0a9f..eb01e4a 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -450,6 +450,17 @@ public final class ActivityManagerService extends ActivityManagerNative
                 + (isFg ? "foreground" : "background") + " queue");
         return (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;
     }
+    // IEM
+    BroadcastRecord broadcastRecordForReceiverLocked(IBinder receiver) {
+        for (BroadcastQueue queue : mBroadcastQueues) {
+            BroadcastRecord r = queue.getMatchingOrderedReceiver(receiver);
+            if (r != null) {
+                return r;
+            }
+        }
+        return null;
+    }
+    // IEM
 
     /**
      * Activity we have told the window manager to have key focus.
@@ -3266,15 +3277,6 @@ public final class ActivityManagerService extends ActivityManagerNative
         checkTime(startTime, "startProcess: done updating cpu stats");
 
         try {
-            try {
-                if (AppGlobals.getPackageManager().isPackageFrozen(app.info.packageName)) {
-                    // This is caught below as if we had failed to fork zygote
-                    throw new RuntimeException("Package " + app.info.packageName + " is frozen!");
-                }
-            } catch (RemoteException e) {
-                throw e.rethrowAsRuntimeException();
-            }
-
             int uid = app.uid;
             int[] gids = null;
             int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
@@ -7076,8 +7078,64 @@ public final class ActivityManagerService extends ActivityManagerNative
             return ActivityManagerService.this.checkComponentPermission(permission, pid, uid,
                     owningUid, exported);
         }
+        //IEM
+        @Override
+        public final int startActivityAsUser(IApplicationThread caller, String callingPackage,
+                Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
+                int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {
+            return ActivityManagerService.this.startActivityAsUser(caller, callingPackage, intent,
+                resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options,
+                userId);
+        }
+
+        @Override
+        public int bindService(IApplicationThread caller, IBinder token,
+                Intent service, String resolvedType,
+                IServiceConnection connection, int flags, int userId) {
+            try {
+                return ActivityManagerService.this.bindService(caller, token, service, resolvedType, connection, flags, service.getPackage(), userId);
+            }
+            catch(TransactionTooLargeException tle){
+                return -1;
+            }
+        }
 
         @Override
+        public IBinder peekService(Intent service, String resolvedType) {
+            return ActivityManagerService.this.peekService(service, resolvedType, service.getPackage());
+        }
+
+        @Override
+        public ComponentName startService(IApplicationThread caller, Intent service,
+                String resolvedType, int userId) {
+            try {
+                return ActivityManagerService.this.startService(caller, service, resolvedType, service.getPackage(), userId);
+            }
+            catch(TransactionTooLargeException tle){
+                return null;
+            }
+        }
+
+        @Override
+        public int stopService(IApplicationThread caller, Intent service,
+                String resolvedType, int userId) {
+            return ActivityManagerService.this.stopService(caller, service, resolvedType, userId);
+        }
+
+        @Override
+         public int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo,
+                 int resultCode, String resultData, Bundle map, String[] requiredPermissions, int appOp, boolean serialized,
+                 boolean sticky, int userId) {
+            return ActivityManagerService.this.broadcastIntent(caller, intent, resolvedType, resultTo, resultCode, resultData,
+                map, requiredPermissions, appOp, null, serialized, sticky, userId);
+        }
+
+        @Override
+        public Context getSystemContext() {
+            return mContext;
+        }
+        //
+        @Override
         public Object getAMSLock() {
             return ActivityManagerService.this;
         }
diff --git a/services/core/java/com/android/server/firewall/IntentFirewall.java b/services/core/java/com/android/server/firewall/IntentFirewall.java
index 62114cd..9153e25 100644
--- a/services/core/java/com/android/server/firewall/IntentFirewall.java
+++ b/services/core/java/com/android/server/firewall/IntentFirewall.java
@@ -17,19 +17,31 @@
 package com.android.server.firewall;
 
 import android.app.AppGlobals;
+import android.app.ApplicationThreadNative;
 import android.content.ComponentName;
+import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.ApplicationInfo;
+import android.content.ServiceConnection;
+import android.content.IIntentReceiver;
+import android.app.IApplicationThread;
+import android.app.IServiceConnection;
+import android.app.ProfilerInfo;
 import android.content.pm.IPackageManager;
 import android.content.pm.PackageManager;
 import android.os.Environment;
 import android.os.FileObserver;
 import android.os.Handler;
+import android.os.IBinder;
 import android.os.Looper;
 import android.os.Message;
+import android.os.Messenger;
 import android.os.RemoteException;
+import android.os.UserHandle;
+import android.os.Bundle;
 import android.util.ArrayMap;
+import android.util.Log;
 import android.util.Slog;
 import android.util.Xml;
 import com.android.internal.util.ArrayUtils;
@@ -41,12 +53,17 @@ import org.xmlpull.v1.XmlPullParserException;
 
 import java.io.File;
 import java.io.FileInputStream;
+import java.io.InputStreamReader;
+import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Set;
+
+import ariel.providers.ArielSettings;
 
 public class IntentFirewall {
     static final String TAG = "IntentFirewall";
@@ -64,7 +81,22 @@ public class IntentFirewall {
 
     private static final int TYPE_ACTIVITY = 0;
     private static final int TYPE_BROADCAST = 1;
-    private static final int TYPE_SERVICE = 2;
+    private static final int TYPE_SERVICE   = 2;
+
+    //IEM
+    private static final int CHECK_INTENT = 1;
+
+    private static final int BLOCK_INTENT   = 0;
+    private static final int ALLOW_INTENT   = 1;
+    private static final int FORWARD_INTENT = 2;
+
+    private static final String IFW_TOKEN = "INTENT_FIREWALL_TOKEN";
+    private static final String IFW_SERVICE_ACTION = "IFW_SERVICE_ACTION";
+
+    private static final int TOKEN_VALID       = 0;
+    private static final int TOKEN_NOT_PRESENT = 1;
+    private static final int TOKEN_CORRUPT     = 2;
+    //IEM
 
     private static final HashMap<String, FilterFactory> factoryMap;
 
@@ -76,6 +108,15 @@ public class IntentFirewall {
     private FirewallIntentResolver mBroadcastResolver = new FirewallIntentResolver();
     private FirewallIntentResolver mServiceResolver = new FirewallIntentResolver();
 
+    //IEM
+    private static boolean forwardUserFirewall = false;
+    private static ComponentName mUserFirewall;
+
+    private UFWServiceConnection mUFW_SC = new UFWServiceConnection();
+    private Messenger mUFWMessenger = new Messenger(new UFWHandler());
+    private Messenger mUFWService;
+    //IEM
+
     static {
         FilterFactory[] factories = new FilterFactory[] {
                 AndFilter.FACTORY,
@@ -115,36 +156,249 @@ public class IntentFirewall {
         rulesDir.mkdirs();
 
         readRulesDir(rulesDir);
+        //IEM
+        /*
+         * Ubaciti da se cita iz ariel secure settings;
+         * Dodati observer na taj setting, pa kad se promeni svaki put, rasturiti firewall
+         */
+        loadUserFirewall(rulesDir);
+        //IEM
 
         mObserver = new RuleObserver(rulesDir);
         mObserver.startWatching();
     }
+    //IEM
+    /**
+     * Given an intent, generates a token.
+     */
+    private String generateToken() {
+        //TODO implement tokenizer
+        return "I am not a secure token";
+    }
+
+    /**
+     * Checks an intent for a token and if it's there, validates it.
+     */
+    private int validateToken(Intent intent) {
+        String token = intent.ifwToken;
+        if (token == null) return TOKEN_NOT_PRESENT;
+        if (generateToken().equals(token)) return TOKEN_VALID;
+        return TOKEN_CORRUPT;
+    }
 
+    private void sendActivityToUserFirewall(IApplicationThread caller, String callingPackage,
+            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
+            int startFlags, Bundle options, int userId) {
+        Log.i(TAG, "In sendActivityToUserFirewall method");
+        // Tokenize intent
+        intent.ifwToken = generateToken();
+        // Package bundle
+        Bundle data = new Bundle();
+        if (caller != null) data.putBinder("caller", caller.asBinder());
+        data.putString("callingPackage", callingPackage);
+        data.putParcelable("intent", intent);
+        data.putInt("intentType", TYPE_ACTIVITY);
+        data.putString("resolvedType", resolvedType);
+        data.putBinder("resultTo", resultTo);
+        data.putString("resultWho", resultWho);
+        data.putInt("requestCode", requestCode);
+        data.putInt("startFlags", startFlags);
+        data.putBundle("options", options);
+        data.putInt("userId", userId);
+        // Prepare message
+        Message msg = Message.obtain(null, CHECK_INTENT);
+        msg.setData(data);
+        msg.replyTo = mUFWMessenger;
+        // Send message
+        try {
+            mUFWService.send(msg);
+        } catch (RemoteException e) {
+            Slog.w(TAG, "Failed to send check intent message to user firewall.");
+        }
+    }
+
+    private void sendServiceToUserFirewall(IApplicationThread caller, IBinder token, Intent service,
+            String resolvedType, IServiceConnection connection, int flags, int userId, String action,
+            int callerUid, int callerPid, String callerPackage) {
+        // Make sure user firewall is bound
+        if (mUFWService == null) {
+            Slog.w(TAG, "User firewall is enabled, but not bound yet. Dropping service intent.");
+            return;
+        }
+        // Tokenize intent
+        service.ifwToken = generateToken();
+        // Package bundle
+        Bundle data = new Bundle();
+        if (caller != null) data.putBinder("caller", caller.asBinder());
+        data.putBinder("token", token);
+        data.putString(IFW_SERVICE_ACTION, action);
+        data.putParcelable("intent", service);
+        data.putInt("intentType", TYPE_SERVICE);
+        data.putString("resolvedType", resolvedType);
+        if (connection != null) data.putBinder("connection", connection.asBinder());
+        data.putInt("flags", flags);
+        data.putInt("userId", userId);
+        data.putString("callingPackage", callerPackage);
+        data.putInt("callerUid", callerUid);
+        data.putInt("callerPid", callerPid);
+        // Prepare message
+        Message msg = Message.obtain(null, CHECK_INTENT);
+        msg.setData(data);
+        msg.replyTo = mUFWMessenger;
+        try {
+            mUFWService.send(msg);
+        } catch (RemoteException e) {
+            Slog.w(TAG, "Failed to send check intent message to user firewall.");
+            return;
+        }
+    }
+
+    private void sendBroadcastToUserFirewall(IApplicationThread caller, Intent intent,
+            String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle map,
+            String requiredPermission, int appOp, boolean serialized, boolean sticky, int userId) {
+        // Tokenize intent
+        intent.ifwToken = generateToken();
+        // Package bundle
+        Bundle data = new Bundle();
+        if (caller != null) data.putBinder("caller", caller.asBinder());
+        data.putParcelable("intent", intent);
+        data.putInt("intentType", TYPE_BROADCAST);
+        data.putString("resolvedType", resolvedType);
+        if (resultTo != null) data.putBinder("resultTo", resultTo.asBinder());
+        data.putInt("resultCode", resultCode);
+        data.putString("resultData", resultData);
+        data.putBundle("map", map);
+        data.putString("requiredPermission", requiredPermission);
+        data.putInt("appOp", appOp);
+        data.putBoolean("serialized", serialized);
+        data.putBoolean("sticky", sticky);
+        data.putInt("userId", userId);
+        // Prepare message
+        Message msg = Message.obtain(null, CHECK_INTENT);
+        msg.setData(data);
+        msg.replyTo = mUFWMessenger;
+        // Send message
+        try {
+            mUFWService.send(msg);
+        } catch (RemoteException e) {
+            Slog.w(TAG, "Failed to send check intent message to user firewall.");
+        }
+    }
+    //IEM
     /**
      * This is called from ActivityManager to check if a start activity intent should be allowed.
      * It is assumed the caller is already holding the global ActivityManagerService lock.
      */
     public boolean checkStartActivity(Intent intent, int callerUid, int callerPid,
             String resolvedType, ApplicationInfo resolvedApp) {
-        return checkIntent(mActivityResolver, intent.getComponent(), TYPE_ACTIVITY, intent,
+        int res = checkIntent(mActivityResolver, intent.getComponent(), TYPE_ACTIVITY, intent,
                 callerUid, callerPid, resolvedType, resolvedApp.uid);
+        Log.i(TAG, "checkStartActivity method, res = "+res);
+        switch(res) {
+            case ALLOW_INTENT:
+                return true;
+            case BLOCK_INTENT:
+                return false;
+            case FORWARD_INTENT:
+                sendActivityToUserFirewall(null, resolvedApp.packageName, intent, resolvedType, null, null,
+                        -1 , intent.getFlags() , null, 0);
+                return false;
+        }
+        return false;
     }
 
-    public boolean checkService(ComponentName resolvedService, Intent intent, int callerUid,
+    public int checkService(ComponentName resolvedService, Intent intent, int callerUid,
             int callerPid, String resolvedType, ApplicationInfo resolvedApp) {
-        return checkIntent(mServiceResolver, resolvedService, TYPE_SERVICE, intent, callerUid,
+        int res = checkIntent(mServiceResolver, resolvedService, TYPE_SERVICE, intent, callerUid,
                 callerPid, resolvedType, resolvedApp.uid);
+        Log.i(TAG, "In checkService method, res = "+res);
+        switch(res) {
+            case ALLOW_INTENT:
+                return 0;
+            case BLOCK_INTENT:
+                return 1;
+            case FORWARD_INTENT:
+                sendServiceToUserFirewall(null, null, intent, resolvedType, null, intent.getFlags(), 0,
+                    intent.getAction(), callerUid, callerPid, resolvedApp.packageName);
+                return 2;
+        }
+        return 1;
     }
 
     public boolean checkBroadcast(Intent intent, int callerUid, int callerPid,
             String resolvedType, int receivingUid) {
-        return checkIntent(mBroadcastResolver, intent.getComponent(), TYPE_BROADCAST, intent,
+        int res = checkIntent(mBroadcastResolver, intent.getComponent(), TYPE_BROADCAST, intent,
                 callerUid, callerPid, resolvedType, receivingUid);
+        Log.i(TAG, "checkBroadcast method, res = "+res);
+        switch(res) {
+            case ALLOW_INTENT:
+                return true;
+            case BLOCK_INTENT:
+                return false;
+            case FORWARD_INTENT:
+                sendBroadcastToUserFirewall(null, intent, resolvedType, null, -1, null,
+                    null, null, -1, false,  false, 0);
+                return true;
+        }
+        return false;
+    }
+
+    /**
+     * This method performs the bulk of the intent checking. It returns an int to advise the caller to either
+     * block the intent, allow the intent, or forward the intent to the user firewall.
+     */
+    public int checkIntent(FirewallIntentResolver resolver, ComponentName resolvedComponent,
+            int intentType, Intent intent, int callerUid, int callerPid, String resolvedType,
+            int receivingUid) {
+
+        // Mandatory Access Control
+        boolean mac = checkMAC(resolver, resolvedComponent, intentType, intent, callerUid,
+            callerPid, resolvedType, receivingUid);
+        // If it failed the MAC, get rid of it!
+        if (!mac) return BLOCK_INTENT;
+
+        if(mUFWService==null){
+            Log.i(TAG, "Jebo ga konj null je!");
+        }
+
+        // If there isn't a userfirewall, then MAC is all we check
+        if (mUFWService == null) return ALLOW_INTENT;
+
+        // At this point, the intent has passed MAC and there is a user firewall. If it is a system
+        // intent, we'll allow it because we don't want the user firewall to be able to block intents which
+        // are critical to the system's stability.
+        if (!UserHandle.isApp(callerUid)) return ALLOW_INTENT;
+
+        // We also allow the intent to bypass the user firewall if it is an intra-app intent. This is because
+        // the user firewall's purpose is to inspect intents which travel between apps, not intents being
+        // sent and received from within the same app.
+        if (intent.getPackage() != null && resolvedComponent != null)
+            if (intent.getPackage().equals(resolvedComponent.getPackageName()))
+                return ALLOW_INTENT;
+
+        // If it isn't sent by system, then it was sent by a normal app. If it has a valid token, then it
+        // has already been through the user firewall and we can allow it. If it has no token, we'll advise
+        // the caller to tokenize and forward it. If there is a token but it's invalid, something bad has
+        // happened and this intent needs to be blocked.
+        int tokenCheck = validateToken(intent);
+        if (tokenCheck == TOKEN_VALID) return ALLOW_INTENT;
+        if (tokenCheck == TOKEN_NOT_PRESENT) return FORWARD_INTENT;
+        // Token was corrupt. This is very bad.
+        Slog.w(TAG, "Blocking corrupted token from " + intent.getPackage());
+        return BLOCK_INTENT;
     }
 
-    public boolean checkIntent(FirewallIntentResolver resolver, ComponentName resolvedComponent,
+    /**
+     * Checks intent against intent firewall's rules to determine if the intent should be
+     * allowed and/or logged. Since these rules come from the intent firewall's rules list,
+     * this is mandatory access control.
+     *
+     * Returns true if the intent should be allowed.
+     */
+    private boolean checkMAC(FirewallIntentResolver resolver, ComponentName resolvedComponent,
             int intentType, Intent intent, int callerUid, int callerPid, String resolvedType,
             int receivingUid) {
+
         boolean log = false;
         boolean block = false;
 
@@ -157,6 +411,34 @@ public class IntentFirewall {
         }
         resolver.queryByComponent(resolvedComponent, candidateRules);
 
+        // Check for userId Rules
+        String compPackage = "";
+        if(resolvedComponent!=null)
+            compPackage = resolvedComponent.getPackageName();
+
+        Log.i(TAG, "callerUid in checkMac = "+callerUid+", receivingUid = "+receivingUid+" with packageName: "+intent.getPackage()+" resolved comp: "+compPackage);
+        if (callerUid > 0)
+            resolver.queryByUserId(Integer.toString(callerUid), candidateRules);
+
+        // Check for data rules
+        resolver.queryByData(intent.getDataString(), candidateRules);
+//
+//        // Check for extra rules
+        resolver.queryByExtra(intent, candidateRules);
+//
+//        // Check for PackagePair Rules
+        int packagePairMatches = 0;
+//        // First check for explicit matches
+        if(resolvedComponent!=null) {
+            if (intent.getPackage() != null && resolvedComponent.getPackageName() != null) {
+                packagePairMatches =
+                        resolver.queryByPackagePair(new PackagePair(intent.getPackage(), resolvedComponent.getPackageName()), candidateRules);
+                // If there are no explicit matches, check for wildcard matches
+                if (packagePairMatches == 0)
+                    resolver.queryByPackagePair(new PackagePair(intent.getPackage(), "*"), candidateRules);
+            }
+        }
+
         // For the second pass, try to match the potentially more specific conditions in each
         // rule against the intent
         for (int i=0; i<candidateRules.size(); i++) {
@@ -255,6 +537,83 @@ public class IntentFirewall {
     }
 
     /**
+     * Looks for a file named uf.config and tries to unflatten it into a ComponentName for the
+     * user firewall service. The intent firewall will forward non-system access control decisions
+     * to this service component.
+     */
+    private void loadUserFirewall(File rulesDir) {
+        // If there currently is a user firewall, make sure we're unbound from it.
+        if (mUserFirewall != null) {
+            try {
+                mAms.getSystemContext().unbindService(mUFW_SC);
+            } catch (Exception e) {
+                Slog.w(TAG, "Tried to unbind from user firewall, but failed.");
+            }
+        }
+        // Discard old user firewall settings
+        mUserFirewall = null;
+        forwardUserFirewall = false;
+
+//        String componentName = ArielSettings.Secure.getString(mAms.getSystemContext().getContentResolver(),
+//                ArielSettings.Secure.ARIEL_INTENT_FILTER_SERVICE);
+//
+//        if(componentName != null && componentName.length()>0){
+//            mUserFirewall = ComponentName.unflattenFromString("com.ariel.guardian/.services.IntentFirewallService");
+//        }
+        mUserFirewall = ComponentName.unflattenFromString("com.ariel.guardian/.services.IntentFirewallService");
+
+//        File[] files = rulesDir.listFiles();
+//        for (int i=0; i<files.length; i++) {
+//            File file = files[i];
+//            if (file.getName().endsWith("uf.config")) {
+//                FileInputStream fis;
+//                BufferedReader br;
+//                try {
+//                    fis = new FileInputStream(file);
+//                    br = new BufferedReader(new InputStreamReader(fis));
+//                } catch (Exception ex) {
+//                    Slog.e(TAG, "Failed to open file: " + file.getName());
+//                    continue;
+//                }
+//                try {
+//                    String compString = br.readLine();
+//                    br.close();
+//                    mUserFirewall = ComponentName.unflattenFromString(compString);
+//                    Slog.i(TAG, "Enabled user firwall: " + mUserFirewall.toShortString());
+//                    // There should only be one uf.config
+//                    break;
+//                } catch (Exception ex) {
+//                    Slog.e(TAG, "Failed to unflatten user firewall component.");
+//                    continue;
+//                }
+//            }
+//        }
+
+        if (mUserFirewall == null) {
+            Slog.i(TAG, "Disabled user firewall.");
+        } else {
+            bindToUFW();
+        }
+    }
+
+    /**
+     * Attempt to bind to the user firewall.
+     */
+    private void bindToUFW() {
+        if (mUserFirewall != null) {
+            try {
+                Intent service = new Intent();
+                service.setComponent(mUserFirewall);
+                mAms.getSystemContext().bindService(service, mUFW_SC, Context.BIND_AUTO_CREATE);
+                Slog.i(TAG, "Sent bind request to user firewall.");
+            } catch (Exception e) {
+                Slog.w(TAG, "Unable to find user firewall, retrying later...");
+                mHandler.sendEmptyMessageDelayed(2, 5000);
+            }
+        }
+    }
+
+    /**
      * Reads rules from all xml files (*.xml) in the given directory, and replaces our set of rules
      * with the newly read rules.
      *
@@ -377,6 +736,18 @@ public class IntentFirewall {
                 for (int i=0; i<rule.getComponentFilterCount(); i++) {
                     resolver.addComponentFilter(rule.getComponentFilter(i), rule);
                 }
+                for (int i=0; i<rule.getPackagePairFilterCount(); i++) {
+                    resolver.addPackagePairFilter(rule.getPackagePair(i), rule);
+                }
+                for (int i=0; i<rule.getUserFilterCount(); i++) {
+                    resolver.addUserIdFilter(rule.getUserId(i), rule);
+                }
+                for (int i=0; i<rule.getDataFilterCount(); i++) {
+                    resolver.addDataFilter(rule.getData(i), rule);
+                }
+                for (int i=0; i<rule.getExtraFilterCount(); i++) {
+                    resolver.addExtraFilter(rule.getExtra(i), rule);
+                }
             }
         }
     }
@@ -414,6 +785,16 @@ public class IntentFirewall {
         private static final String TAG_INTENT_FILTER = "intent-filter";
         private static final String TAG_COMPONENT_FILTER = "component-filter";
         private static final String ATTR_NAME = "name";
+        private static final String TAG_PACKAGE_FILTER = "package-filter";
+        private static final String ATTR_SENDER = "sender";
+        private static final String ATTR_RECEIVER = "receiver";
+        private static final String TAG_USER = "user-id";
+        private static final String ATTR_USER_ID = "sender";
+        private static final String TAG_DATA = "data";
+        private static final String ATTR_CONTAINS = "contains";
+        private static final String TAG_EXTRA = "extra";
+        private static final String ATTR_TYPE = "type";
+        private static final String ATTR_VALUE = "value";
 
         private static final String ATTR_BLOCK = "block";
         private static final String ATTR_LOG = "log";
@@ -421,6 +802,10 @@ public class IntentFirewall {
         private final ArrayList<FirewallIntentFilter> mIntentFilters =
                 new ArrayList<FirewallIntentFilter>(1);
         private final ArrayList<ComponentName> mComponentFilters = new ArrayList<ComponentName>(0);
+        private final ArrayList<PackagePair> mPackagePairFilters = new ArrayList<PackagePair>(0);
+        private final ArrayList<String> mUserFilters = new ArrayList<String>(0);
+        private final ArrayList<String> mDataFilters = new ArrayList<String>(0);
+        private final ArrayList<String[]> mExtraFilters = new ArrayList<String[]>(0);
         private boolean block;
         private boolean log;
 
@@ -437,10 +822,44 @@ public class IntentFirewall {
         protected void readChild(XmlPullParser parser) throws IOException, XmlPullParserException {
             String currentTag = parser.getName();
 
+            // Intent filter
             if (currentTag.equals(TAG_INTENT_FILTER)) {
                 FirewallIntentFilter intentFilter = new FirewallIntentFilter(this);
                 intentFilter.readFromXml(parser);
                 mIntentFilters.add(intentFilter);
+            // User filter
+            } else if (currentTag.equals(TAG_USER)) {
+                String userId = parser.getAttributeValue(null, ATTR_USER_ID);
+                if (userId == null) {
+                    throw new XmlPullParserException("Id of user cannot be null.", parser, null);
+                }
+                mUserFilters.add(userId);
+            // Data filter
+            } else if (currentTag.equals(TAG_DATA)) {
+                String dataContains = parser.getAttributeValue(null, ATTR_CONTAINS);
+                if (dataContains == null) {
+                    throw new XmlPullParserException("Data contains attribute cannot be null.");
+                }
+                mDataFilters.add(dataContains);
+            // Extra filter
+            } else if (currentTag.equals(TAG_EXTRA)) {
+                String extraType = parser.getAttributeValue(null, ATTR_TYPE);
+                String extraValue = parser.getAttributeValue(null, ATTR_VALUE);
+                if (extraType == null || extraValue == null) {
+                    throw new XmlPullParserException("Extra rules must contain type and value.");
+                }
+                String[] extraRule = {extraType, extraValue};
+                mExtraFilters.add(extraRule);
+            // Package filter
+            } else if (currentTag.equals(TAG_PACKAGE_FILTER)) {
+                String senderPackage = parser.getAttributeValue(null, ATTR_SENDER);
+                String receiverPackage = parser.getAttributeValue(null, ATTR_RECEIVER);
+                if (senderPackage == null || receiverPackage == null) {
+                    throw new XmlPullParserException("Package sender and receiver must be specified.",
+                            parser, null);
+                }
+                mPackagePairFilters.add(new PackagePair(senderPackage, receiverPackage));
+            // Component filter
             } else if (currentTag.equals(TAG_COMPONENT_FILTER)) {
                 String componentStr = parser.getAttributeValue(null, ATTR_NAME);
                 if (componentStr == null) {
@@ -471,9 +890,42 @@ public class IntentFirewall {
             return mComponentFilters.size();
         }
 
+        public int getPackagePairFilterCount() {
+            return mPackagePairFilters.size();
+        }
+
+        public int getUserFilterCount() {
+            return mUserFilters.size();
+        }
+
+        public int getDataFilterCount() {
+            return mDataFilters.size();
+        }
+
+        public int getExtraFilterCount() {
+            return mExtraFilters.size();
+        }
+
         public ComponentName getComponentFilter(int index) {
             return mComponentFilters.get(index);
         }
+
+        public PackagePair getPackagePair(int index) {
+            return mPackagePairFilters.get(index);
+        }
+
+        public String getUserId(int index) {
+            return mUserFilters.get(index);
+        }
+
+        public String getData(int index) {
+            return mDataFilters.get(index);
+        }
+
+        public String[] getExtra(int index) {
+            return mExtraFilters.get(index);
+        }
+
         public boolean getBlock() {
             return block;
         }
@@ -532,8 +984,162 @@ public class IntentFirewall {
             mRulesByComponent.put(componentName, rules);
         }
 
+        public int queryByPackagePair(PackagePair packagePair, List<Rule> candidateRules) {
+            Rule[] rules = mRulesByPackagePair.get(packagePair);
+            if (rules != null) {
+                candidateRules.addAll(Arrays.asList(rules));
+                return rules.length;
+            }
+            return 0;
+        }
+
+        public void addPackagePairFilter(PackagePair packagePair, Rule rule) {
+            Rule[] rules = mRulesByPackagePair.get(packagePair);
+            rules = ArrayUtils.appendElement(Rule.class, rules, rule);
+            mRulesByPackagePair.put(packagePair, rules);
+        }
+
+        public int queryByUserId(String userId, List<Rule> candidateRules) {
+            Rule[] rules = mRulesByUserId.get(userId);
+            if (rules != null) {
+                candidateRules.addAll(Arrays.asList(rules));
+                return rules.length;
+            }
+            return 0;
+        }
+
+        public void addUserIdFilter(String userId, Rule rule) {
+            Rule[] rules = mRulesByUserId.get(userId);
+            rules = ArrayUtils.appendElement(Rule.class, rules, rule);
+            mRulesByUserId.put(userId, rules);
+        }
+
+        public int queryByData(String data, List<Rule> candidateRules) {
+            ArrayList<Rule> rulesList = new ArrayList<Rule>(0);
+            for (int i = 0; i < mRulesByData.size(); i++) {
+                Rule[] rules = mRulesByData.valueAt(i);
+                if (rules != null) {
+                    for (int k=0; k<rules.length; k++) {
+                        Rule rule = rules[k];
+                        for (int j=0; j<rule.getDataFilterCount(); j++) {
+                            String ruleData = rule.getData(i);
+                            if (data != null && ruleData != null)
+                                if (data.contains(ruleData))
+                                    rulesList.add(rule);
+                        }
+                    }
+                }
+            }
+
+            if (rulesList.size() > 0) {
+                candidateRules.addAll(rulesList);
+                return rulesList.size();
+            }
+
+            return 0;
+        }
+
+        public int queryByExtra(Intent intent, List<Rule> candidateRules) {
+
+            ArrayList<Rule> rulesList = new ArrayList<Rule>(0);
+            for (int i = 0; i < mRulesByExtra.size(); i++) {
+                Rule[] rules = mRulesByExtra.valueAt(i);
+                if (rules != null) {
+                    for (int k=0; k<rules.length; k++) {
+                        Rule rule = rules[k];
+                        for (int j=0; j<rule.getExtraFilterCount(); j++) {
+                            String[] extraRule = rule.getExtra(i);
+                            String extraType = extraRule[0];
+                            String extraValue = extraRule[1];
+                            if (compareExtra(intent.getExtras(), extraType, extraValue))
+                                rulesList.add(rule);
+                        }
+                    }
+                }
+            }
+
+            if (rulesList.size() > 0) {
+                candidateRules.addAll(rulesList);
+                return rulesList.size();
+            }
+
+            return 0;
+        }
+
+        /**
+         * Helper method for queryByExtra. Takes a bundle, and the type and value for
+         * an extra rule and tries to match them. Returns true if a match was found,
+         * otherwise returns false.
+         */
+        private boolean compareExtra(Bundle extras, String type, String value) {
+
+            // extras could be null, in which case there is nothing to check
+            if (extras == null) return false;
+
+            Set<String> keys = extras.keySet();
+
+            for(String key : keys) {
+                if (type.equalsIgnoreCase("string")) {
+                    String keyValue = extras.getString(key, null);
+                    if (keyValue != null)
+                        if (keyValue.contains(value))
+                            return true;
+                } else if (type.equalsIgnoreCase("int")) {
+                    int keyValue = extras.getInt(key);
+                    if (keyValue != 0) {
+                        try {
+                            if (keyValue == Integer.parseInt(value))
+                                return true;
+                        } catch (Exception e) {
+                            Slog.e(TAG, "Extra rule is type int, but value is not an int");
+                        }
+                    }
+                } else if (type.equalsIgnoreCase("float")) {
+                    float keyValue = extras.getFloat(key);
+                    if (keyValue != 0.0) {
+                        try {
+                            if (keyValue == Float.parseFloat(value))
+                                return true;
+                        } catch (Exception e) {
+                            Slog.e(TAG, "Extra rule is type float, but value is not a float");
+                        }
+                    }
+                }
+            }
+            return false;
+        }
+
+        public void addDataFilter(String data, Rule rule) {
+            Rule[] rules = mRulesByData.get(data);
+            rules = ArrayUtils.appendElement(Rule.class, rules, rule);
+            mRulesByData.put(data, rules);
+        }
+
+        public void addExtraFilter(String[] extra, Rule rule) {
+            Rule[] rules = mRulesByExtra.get(extra);
+            rules = ArrayUtils.appendElement(Rule.class, rules, rule);
+            mRulesByExtra.put(extra, rules);
+        }
+
         private final ArrayMap<ComponentName, Rule[]> mRulesByComponent =
-                new ArrayMap<ComponentName, Rule[]>(0);
+                  new ArrayMap<ComponentName, Rule[]>(0);
+
+        private final ArrayMap<PackagePair, Rule[]> mRulesByPackagePair =
+                  new ArrayMap<PackagePair, Rule[]>(0);
+
+        private final ArrayMap<String, Rule[]> mRulesByData =
+                  new ArrayMap<String, Rule[]>(0);
+
+        private final ArrayMap<String[], Rule[]> mRulesByExtra =
+                  new ArrayMap<String[], Rule[]>(0);
+
+        private final ArrayMap<String, Rule[]> mRulesByUserId =
+                  new ArrayMap<String, Rule[]>(0);
+
+        public int getRulesCount() {
+            return mRulesByComponent.size() + mRulesByPackagePair.size() + filterSet().size() +
+                   mRulesByUserId.size() + mRulesByData.size() + mRulesByExtra.size();
+        }
     }
 
     final FirewallHandler mHandler;
@@ -545,7 +1151,17 @@ public class IntentFirewall {
 
         @Override
         public void handleMessage(Message msg) {
-            readRulesDir(getRulesDir());
+            switch (msg.what) {
+                case 0:
+                    readRulesDir(getRulesDir());
+                    break;
+                case 1:
+                    loadUserFirewall(getRulesDir());
+                    break;
+                case 2:
+                    bindToUFW();
+                    break;
+            }
         }
     };
 
@@ -569,6 +1185,10 @@ public class IntentFirewall {
                 mHandler.removeMessages(0);
                 mHandler.sendEmptyMessageDelayed(0, 250);
             }
+            if (path.endsWith("uf.config")) {
+                mHandler.removeMessages(1);
+                mHandler.sendEmptyMessageDelayed(1, 250);
+            }
         }
     }
 
@@ -576,10 +1196,27 @@ public class IntentFirewall {
      * This interface contains the methods we need from ActivityManagerService. This allows AMS to
      * export these methods to us without making them public, and also makes it easier to test this
      * component.
+     *
+     * This interface must match the IntentFirewallInterface class defined in ActivityManagerService.java.
      */
     public interface AMSInterface {
         int checkComponentPermission(String permission, int pid, int uid,
                 int owningUid, boolean exported);
+        int startActivityAsUser(IApplicationThread caller, String callingPackage,
+                Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
+                int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId);
+        int bindService(IApplicationThread caller, IBinder token,
+                Intent service, String resolvedType,
+                IServiceConnection connection, int flags, int userId);
+        IBinder peekService(Intent service, String resolvedType);
+        ComponentName startService(IApplicationThread caller, Intent service,
+                String resolvedType, int userId);
+        int stopService(IApplicationThread caller, Intent service,
+                String resolvedType, int userId);
+        int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo,
+                int resultCode, String resultData, Bundle map, String[] requiredPermission, int appOp,
+                boolean serialized, boolean sticky, int userId);
+        Context getSystemContext();
         Object getAMSLock();
     }
 
@@ -609,4 +1246,212 @@ public class IntentFirewall {
         }
     }
 
+    /**
+     * Interface so IFW can bind to UFW.
+     */
+    private class UFWServiceConnection implements ServiceConnection {
+
+        @Override
+        public void onServiceConnected(ComponentName comp, IBinder service) {
+            forwardUserFirewall = true;
+            Slog.i(TAG, "Connection to UFW established.");
+            // Store messenger
+            mUFWService = new Messenger(service);
+            if(mUFWService!=null){
+                Log.i(TAG, "mUFWService not null!");
+            }
+            else{
+                Log.i(TAG, "mUFWService is null!");
+            }
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName comp) {
+            forwardUserFirewall = false;
+            mUFWService = null;
+            Slog.w(TAG, "Connection with UFW lost!");
+            mHandler.sendEmptyMessageDelayed(1, 250);
+        }
+    }
+
+    /**
+     * Handler for messages received from the UFW.
+     */
+    private class UFWHandler extends Handler {
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case CHECK_INTENT:
+                    Bundle data = msg.getData();
+                    if (data == null) break;
+                    if (!validateData(data)) break;
+                    int intentType = data.getInt("intentType", -1);
+                    if (intentType == TYPE_ACTIVITY)
+                        sendActivityAsUser(data);
+                    if (intentType == TYPE_SERVICE)
+                        sendServiceAsUser(data);
+                    if (intentType == TYPE_BROADCAST)
+                        sendBroadcastAsUser(data);
+                break;
+            }
+        }
+    }
+
+    /**
+     * Validates bundles received from the user firewall.
+     *
+     * Returns true if the bundle is valid, otherwise returns false.
+     */
+    private boolean validateData(Bundle data) {
+        // Every bundle should have an intent
+        Intent intent = data.getParcelable("intent");
+        if (intent == null) return false;
+        // Every intent should have a valid token
+        if (validateToken(intent) != TOKEN_VALID) return false;
+        // All checks passed
+        return true;
+    }
+
+    private void sendActivityAsUser(Bundle data) {
+        IApplicationThread caller = ApplicationThreadNative.asInterface(data.getBinder("caller"));
+        String callingPackage = data.getString("callingPackage");
+        Intent intent = data.getParcelable("intent");
+        String resolvedType = data.getString("resolvedType");
+        IBinder resultTo = data.getBinder("resultTo");
+        String resultWho = data.getString("resultWho");
+        int requestCode = data.getInt("requestCode");
+        int startFlags = data.getInt("startFlags");
+        Bundle options = data.getBundle("options");
+        int userId = data.getInt("userId");
+
+        int res =  mAms.startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
+            resultWho, requestCode, startFlags, null, options, userId);
+
+        if (res < 0) Slog.w(TAG, "AMS startActivityAsUser returned error: " + res);
+    }
+
+    private void sendServiceAsUser(Bundle data) {
+        // Determine how this service needs to be sent
+        Intent intent = data.getParcelable("intent");
+        String serviceAction = data.getString(IFW_SERVICE_ACTION);
+        if (serviceAction == null) {
+            Slog.w(TAG, "Received service intent from user firewall with no API mark!");
+            return;
+        }
+
+        if (serviceAction.equals("start")) {
+            IApplicationThread caller = ApplicationThreadNative.asInterface(data.getBinder("caller"));
+            String resolvedType = data.getString("resolvedType");
+            int userId = data.getInt("userId");
+            mAms.startService(caller, intent, resolvedType, userId);
+        }
+        if (serviceAction.equals("bind")) {
+            IApplicationThread caller = ApplicationThreadNative.asInterface(data.getBinder("caller"));
+            IBinder token = data.getBinder("token");
+            String resolvedType = data.getString("resolvedType");
+            IServiceConnection connection = IServiceConnection.Stub.asInterface(data.getBinder("connection"));
+            int flags = data.getInt("flags");
+            int userId = data.getInt("userId");
+            mAms.bindService(caller, token, intent, resolvedType, connection, flags, userId);
+        }
+        if (serviceAction.equals("stop")) {
+            IApplicationThread caller = ApplicationThreadNative.asInterface(data.getBinder("caller"));
+            String resolvedType = data.getString("resolvedType");
+            int userId = data.getInt("userId");
+            mAms.stopService(caller, intent, resolvedType, userId);
+        }
+        if (serviceAction.equals("peek")) {
+            String resolvedType = data.getString("resolvedType");
+            mAms.peekService(intent, resolvedType);
+        }
+    }
+
+    private void sendBroadcastAsUser(Bundle data) {
+        IApplicationThread caller = ApplicationThreadNative.asInterface(data.getBinder("caller"));
+        Intent intent = data.getParcelable("intent");
+        String resolvedType = data.getString("resolvedType");
+        IIntentReceiver resultTo = IIntentReceiver.Stub.asInterface(data.getBinder("resultTo"));
+        int resultCode = data.getInt("resultCode");
+        String resultData = data.getString("resultData");
+        Bundle map = data.getBundle("map");
+        String[] requiredPermission = data.getStringArray("requiredPermission");
+        int appOp = data.getInt("appOp");
+        boolean serialized = data.getBoolean("serialized");
+        boolean sticky = data.getBoolean("sticky");
+        int userId = data.getInt("userId");
+
+        int res = mAms.broadcastIntent(caller, intent, resolvedType, resultTo, resultCode, resultData, map,
+            requiredPermission, appOp, serialized, sticky, userId);
+
+        if (res < 0) Slog.w(TAG, "AMS broadcastIntent returned error: " + res);
+    }
+
+    /**
+     * Holds a pair of package names as two strings referring to the sending and receiving
+     * packages.
+     *
+     * This class allows the intent firewall to match intents based on both the sending
+     * and receiving package names. Such a rule can be defined in the following way:
+     *
+     *     <package-filter sender="[package]" receiver="[package]" />
+     *
+     * and will be checked whenever the sender's package name is given to the intent firewall.
+     *
+     * To have a sender match any receiver, set the receiver to "*".
+     */
+    private static final class PackagePair {
+
+        private String senderPackage, receiverPackage;
+
+        /**
+         * @param senderPkg The sender's package name. Cannot be null.
+         * @param receiverPkg The receiver's package name. Cannot be null.
+         */
+        public PackagePair(String senderPkg, String receiverPkg) {
+            if (senderPkg == null) throw new NullPointerException("sender package name is null");
+            if (receiverPkg == null) throw new NullPointerException("receiver package name is null");
+            senderPackage = senderPkg;
+            receiverPackage = receiverPkg;
+        }
+
+        // This class requires a special notion of equality so it is matchable when stored as a key
+        // in an array map.
+        @Override
+        public boolean equals(Object obj) {
+            if (obj == null) {
+                return false;
+            }
+            if (getClass() != obj.getClass()) {
+                return false;
+            }
+            final PackagePair pkg = (PackagePair) obj;
+            if (!this.getSenderPackageName().equals(pkg.getSenderPackageName())) {
+                return false;
+            }
+            if (!this.getReceiverPackageName().equals(pkg.getReceiverPackageName())
+                && !this.getReceiverPackageName().equals("*")) {
+                return false;
+            }
+            return true;
+        }
+
+        // This class also requires a special notion of hash code so it is matchable when stored
+        // as a key in an array map.
+        @Override
+        public int hashCode() {
+            int hash = 3;
+            hash = 53 * hash + this.getSenderPackageName().hashCode();
+            hash = 53 * hash + this.getReceiverPackageName().hashCode();
+            return hash;
+        }
+
+        public String getSenderPackageName() {
+            return senderPackage;
+        }
+
+        public String getReceiverPackageName() {
+            return receiverPackage;
+        }
+    }
 }
diff --git a/services/core/java/com/android/server/policy/PhoneWindowManager.java b/services/core/java/com/android/server/policy/PhoneWindowManager.java
index 259a4e1..9da49fe 100644
--- a/services/core/java/com/android/server/policy/PhoneWindowManager.java
+++ b/services/core/java/com/android/server/policy/PhoneWindowManager.java
@@ -74,7 +74,7 @@ import android.os.SystemProperties;
 import android.os.UEventObserver;
 import android.os.UserHandle;
 import android.os.Vibrator;
-import android.provider.ArielSettings;
+import ariel.providers.ArielSettings;
 import android.provider.MediaStore;
 import android.provider.Settings;
 import android.service.dreams.DreamManagerInternal;
-- 
1.9.1

